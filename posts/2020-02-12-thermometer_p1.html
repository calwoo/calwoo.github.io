<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" type="image/x-icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Thermometer continuations, part 1 - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Thermometer continuations, part 1</h1>
            <article>
    <section class="header">
        Posted on February 12, 2020
        
            by Calvin
        
    </section>
    <section>
        <p><strong>Note: This blog post is still a rough draft. Read on with caution.</strong></p>
<p><span class="math display">\[ \text{&quot;Delimited continuations are the mother of all monads!&quot;} \]</span></p>
<p><strong>NB:</strong> I read this paper awhile ago, but I only recently decided to write a small post about it. You can find the code for this <a href="https://github.com/calwoo/delimited">here</a>.</p>
<p>The famous <a href="https://dl.acm.org/doi/10.1145/174675.178047">1994</a> paper of Filinski showed denotationally that any monadic (computational) effect can be replicated via delimited continuations, e.g. exceptions/state/nondeterminism/etc. However, most languages do not expose continuations as a first-class citizen, as doing so usually involves capturing the function call stack as a value to be passed around in the code.</p>
<p>This post will be a summarized view of the functional pearl of <a href="https://arxiv.org/pdf/1710.10385.pdf">Koppel et al.</a> “Capturing the future by replaying the past”. There they show that in any language with exception and state, you can implement delimited continuations– the style they call as thermometer continuations. This is a cool idea, and allows us to implement multi-shot delimited continuations (i.e. can be used multiple times) in most languages. For reference, Python’s generators are considered one-shot delimited continuations, where the suspended generator after a <code>yield</code> statement is the continuation, but you can only run the continuation once when you decide to resume it.</p>
<p>Before we push onwards in the post, we just get an inkling of the general idea. We stated before that a delimited continuation is like an exception handler that can be resumed after execution– the <code>try</code> block acts as a <code>shift</code> operator where the continuation parameter is given by <code>throw</code>, while the <code>except</code> block is the part of the <code>reset</code> block outside of a shift which demarcates the continuation captured by the shift block. There’s really only one problem– for <code>shift/reset</code>, after applying the continuation, we can resume the computation in the <code>shift</code> block! Exceptions don’t normally do this.</p>
<p>The key intuition is this: just run it again! Actually, this isn’t even the intuition. It’s really the <em>entire</em> idea.</p>
<h3 id="nondeterminism">nondeterminism</h3>
<p>A non-trivial effect that many people see is nondeterminism– if a function has many choices in its execution, then there may not be a single output to a given input. We would like to capture the outputs of all these choices in a composable fashion. The way we usually do this in functional languages is via a monad. For example, the function in Python</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> test_fn():</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> choose([<span class="va">True</span>, <span class="va">False</span>]):</a>
<a class="sourceLine" id="cb1-3" title="3">        <span class="cf">return</span> choose([<span class="dv">1</span>,<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="cf">return</span> choose([<span class="dv">3</span>,<span class="dv">4</span>])</a></code></pre></div>
<p>becomes monadic in Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">test_fn <span class="fu">=</span> [<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2">                <span class="kw">if</span> b</a>
<a class="sourceLine" id="cb2-3" title="3">                <span class="kw">then</span> [<span class="dv">1</span>,<span class="dv">2</span>] <span class="fu">&gt;&gt;=</span> \r <span class="ot">-&gt;</span> <span class="fu">return</span> r</a>
<a class="sourceLine" id="cb2-4" title="4">                <span class="kw">else</span> [<span class="dv">3</span>,<span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> \r <span class="ot">-&gt;</span> <span class="fu">return</span> r</a></code></pre></div>
<p>But it would be nice if Python did have a primitive like <code>choose</code> so that we could write these functions without monads (which when unwinded come down to continuation-passing style). Let’s approach this one step at a time. Suppose we just want to perform nondeterminism with a <em>single choice</em> with only <em>2 options</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> test_fn0():</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="cf">return</span> <span class="dv">3</span> <span class="op">*</span> choose(<span class="dv">5</span>,<span class="dv">6</span>)</a></code></pre></div>
<p>How can we get the list of possible outputs from each possible choice of this function? When the function hits the <code>choose</code> clause, there are two possible paths the function could go– 5 or 6. This has an obvious answer: run it twice, once with each of the choices. In code the <code>choice</code> operator becomes</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># State-bit to record which branch to take during handling.</span></a>
<a class="sourceLine" id="cb4-2" title="2">first_time <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">def</span> choose(x1, x2):</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="cf">if</span> first_time:</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="cf">return</span> x1</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="cf">return</span> x2</a></code></pre></div>
<p>Running the delimited continuation is given by effect handlers, which performs the key idea for thermometer continuations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> with_nondeterminism(fn):</a>
<a class="sourceLine" id="cb5-2" title="2">    results <span class="op">=</span> []</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">global</span> first_time</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co"># Take first branch first</span></a>
<a class="sourceLine" id="cb5-5" title="5">    first_time <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb5-6" title="6">    results.append(fn())</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co"># Take second branch</span></a>
<a class="sourceLine" id="cb5-8" title="8">    first_time <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb5-9" title="9">    results.append(fn())</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="cf">return</span> results</a></code></pre></div>
<p>Running this on examples gives us great results!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;</span> with_nondeterminism(<span class="kw">lambda</span> : <span class="dv">3</span> <span class="op">*</span> choose(<span class="dv">5</span>,<span class="dv">6</span>))</a>
<a class="sourceLine" id="cb6-2" title="2">[<span class="dv">15</span>, <span class="dv">18</span>]</a></code></pre></div>
<p>Let’s extend this a bit to deal with <code>choose</code> clauses with more than two choices. Since a bool can only express 2 values, we need something else to represent the “state” of our continuation. Naturally we’ll store the index (and the total length of the choice list, since we need to know where to stop counting).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># Global state will be a pair, indicating current id of branch,</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co"># and total number of branches</span></a>
<a class="sourceLine" id="cb7-3" title="3">state <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>)</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">def</span> start_idx(xs):</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="cf">return</span> (<span class="dv">0</span>, <span class="bu">len</span>(xs))</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">def</span> next_idx(k, length):</a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="cf">if</span> k <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> length:</a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="cf">return</span> (<span class="va">None</span>, <span class="va">None</span>)</a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb7-12" title="12">        <span class="cf">return</span> (k <span class="op">+</span> <span class="dv">1</span>, length)</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="kw">def</span> get(xs, k, length):</a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="cf">return</span> xs[k]</a></code></pre></div>
<p>Aside from the slightly-added complexity of having an index as global state, the same idea stays the same: <strong>we replay the function repeatedly, each time using a new value of the choice function</strong>. Now the <code>choose</code> operator is a suitably extended version of the 2-choice version above:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">def</span> choose(xs):</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">global</span> state</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="cf">if</span> <span class="bu">len</span>(xs) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;it's the end&quot;</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-6" title="6">        <span class="co"># Grab a value based on the current global state</span></a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb8-8" title="8">            state <span class="op">=</span> start_idx(xs)</a>
<a class="sourceLine" id="cb8-9" title="9">            <span class="cf">return</span> get(xs, <span class="op">*</span>state)</a>
<a class="sourceLine" id="cb8-10" title="10">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-11" title="11">            <span class="cf">return</span> get(xs, <span class="op">*</span>state)</a></code></pre></div>
<p>where the effect handler <code>with_nondeterminism</code> is updated to run through the index state one-by-one, as opposed to just flipping a boolean state:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">def</span> with_nondeterminism(fn):</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">global</span> state</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="co"># Run the function with current state</span></a>
<a class="sourceLine" id="cb9-5" title="5">        results <span class="op">=</span> [fn()]</a>
<a class="sourceLine" id="cb9-6" title="6">        <span class="cf">if</span> state[<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb9-7" title="7">            <span class="cf">return</span> results</a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb9-9" title="9">            <span class="cf">if</span> next_idx(<span class="op">*</span>state)[<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb9-10" title="10">                <span class="cf">return</span> results</a>
<a class="sourceLine" id="cb9-11" title="11">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb9-12" title="12">                state <span class="op">=</span> next_idx(<span class="op">*</span>state)</a>
<a class="sourceLine" id="cb9-13" title="13">                <span class="cf">return</span> results <span class="op">+</span> with_nondeterminism(fn)</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="cf">except</span> <span class="pp">ValueError</span>:</a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="cf">return</span> []</a></code></pre></div>
<p>However, we notice that our global state can only deal with a single <code>choose</code> operator– how do we extend this to deal with multiple choose branches as in the original <code>test_fn</code> above? If you think about what the function execution would look like with all choices enumerated, this looks like a (stateful) tree. Performing a traversal of this tree while keeping state is effectively what an effect handler for <code>choose</code> would be doing! So taking a cue from iterative <a href="https://stackoverflow.com/questions/1294701/post-order-traversal-of-binary-tree-without-recursion">traversal</a> techniques (see? coding interviews are helpful!), we will keep along our global state two stacks: the <strong>future</strong> and the <strong>past</strong>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">past   <span class="op">=</span> []</a>
<a class="sourceLine" id="cb10-2" title="2">future <span class="op">=</span> []</a></code></pre></div>
<p>The <code>past</code> contains choices already made. The <code>future</code> contains the known choices <em>to be</em> made. The basic idea is that we record in our stacks the path taken by the execution of the program (this is similar to MCMC done in probabilistic programming languages). We then modify a single choice in our path at each new iteration, until we have exhausted all the possible paths possible through the tree.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">def</span> next_path(xs):</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="cf">if</span> <span class="bu">len</span>(xs) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb11-3" title="3">        <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-5" title="5">        i <span class="op">=</span> xs[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb11-6" title="6">        <span class="cf">if</span> next_idx(<span class="op">*</span>i)[<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb11-7" title="7">            <span class="cf">return</span> next_path(xs[<span class="dv">1</span>:])</a>
<a class="sourceLine" id="cb11-8" title="8">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-9" title="9">            <span class="cf">return</span> [next_idx(<span class="op">*</span>i)] <span class="op">+</span> xs[<span class="dv">1</span>:]</a></code></pre></div>
<p>How is this handler supposed to work? When the execution of the handler reaches a call to choose, it reads the choice from the future stack, and pushes the remainder to the past. If the future is unknown, then it means we have reached a choose statement for the first time, at which we pick the first choice and record it in the past stack.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">def</span> choose(xs):</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">global</span> past, future</a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="cf">if</span> <span class="bu">len</span>(xs) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;it's the end&quot;</span>)</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb12-6" title="6">        <span class="cf">if</span> <span class="bu">len</span>(future) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb12-7" title="7">            <span class="co"># If there is no future, start a new path index and</span></a>
<a class="sourceLine" id="cb12-8" title="8">            <span class="co"># push it into the past.</span></a>
<a class="sourceLine" id="cb12-9" title="9">            i <span class="op">=</span> start_idx(xs)</a>
<a class="sourceLine" id="cb12-10" title="10">            past.insert(<span class="dv">0</span>, i)</a>
<a class="sourceLine" id="cb12-11" title="11">            <span class="cf">return</span> get(xs, <span class="op">*</span>i)</a>
<a class="sourceLine" id="cb12-12" title="12">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb12-13" title="13">            <span class="co"># Otherwise, read the instruction from the future stack</span></a>
<a class="sourceLine" id="cb12-14" title="14">            <span class="co"># and execute, pushing back into the past.</span></a>
<a class="sourceLine" id="cb12-15" title="15">            i <span class="op">=</span> future.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb12-16" title="16">            past.insert(<span class="dv">0</span>, i)</a>
<a class="sourceLine" id="cb12-17" title="17">            <span class="cf">return</span> get(xs, <span class="op">*</span>i)</a>
<a class="sourceLine" id="cb12-18" title="18"></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="kw">def</span> with_nondeterminism(fn):</a>
<a class="sourceLine" id="cb12-20" title="20">    <span class="kw">global</span> past, future</a>
<a class="sourceLine" id="cb12-21" title="21">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb12-22" title="22">        results <span class="op">=</span> [fn()]</a>
<a class="sourceLine" id="cb12-23" title="23">        next_future <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(next_path(past)))</a>
<a class="sourceLine" id="cb12-24" title="24">        <span class="co"># Reset past/future stacks</span></a>
<a class="sourceLine" id="cb12-25" title="25">        past   <span class="op">=</span> []</a>
<a class="sourceLine" id="cb12-26" title="26">        future <span class="op">=</span> next_future</a>
<a class="sourceLine" id="cb12-27" title="27">        <span class="cf">if</span> <span class="bu">len</span>(future) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb12-28" title="28">            <span class="cf">return</span> results</a>
<a class="sourceLine" id="cb12-29" title="29">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb12-30" title="30">            <span class="cf">return</span> results <span class="op">+</span> with_nondeterminism(fn)</a>
<a class="sourceLine" id="cb12-31" title="31">    <span class="cf">except</span> <span class="pp">ValueError</span>:</a>
<a class="sourceLine" id="cb12-32" title="32">        <span class="cf">return</span> []</a></code></pre></div>
<p>Testing this gives us the expected behavior:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1"><span class="op">&gt;</span> with_nondeterminism(test_fn)</a>
<a class="sourceLine" id="cb13-2" title="2">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a></code></pre></div>
<h3 id="next-steps">next steps</h3>
<p>And that’s pretty much it. Delimited continuations are only a slightly more complicated version of this– we are traversing paths through execution trees as well, except this time the trees have state in their nodes. In the next post we’ll start looking at delimited continuations in the <code>shift/reset</code> paradigm and use this to build some cool algebraic effects in Python.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
