<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" type="image/x-icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Algebraic effects and freeness - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Algebraic effects and freeness</h1>
            <article>
    <section class="header">
        Posted on February  9, 2020
        
            by Calvin
        
    </section>
    <section>
        <p><strong>Note: This blog post is still a rough draft. Read on with caution.</strong></p>
<p>This post is mostly for my own personal benefit, as I’ve been trying for the past few months to understand the circle of ideas between delimited continuations, algebraic effects, and probabilistic programming. Those looking for true elucidation would do no better than pivoting to the works of <a href="http://okmij.org/">Oleg Kiselyov</a> and bask in his writing. Anything else you read will be a mere shadow.</p>
<p>Anyway, why <strong>effects</strong>? Effects give the impurity to programming languages. In the end, the program has to do something beyond the functions whether it be mutating state, writing something to <code>stdout</code>, taking in external input, etc. A lot of semantical choices can be made to control these effects from doing untold damage to your codebase, the most well-known of which in the functional programming community is to encapsulate the effects into a monad.</p>
<p>Monads are an encapsulation of a computational effect, and their definitions abstract away the process of “effect propagation” through a sequential process. Indeed, the <code>bind</code> (<code>&gt;&gt;=</code>) command abstracts the propagation of effects such as choice/failure/state/logging/etc through a program. For example, let’s describe the <code>State</code> monad.</p>
<p>Intuitively, in a functional language without mutable state we have to pass the state <code>s</code> around with us throughout all our functions. If we’re given a function <code>a -&gt; b</code> that may require state, we can naively pass it along by accepting the state explicitly as a reified object <code>(a, s) -&gt; (b, s)</code>. Writing our code this way makes it clear that we can have composable functions-with-state-attached and be perfectly happy with it. However, we’d like to hide this state a bit, so the first bit of cleaning up is through a currying:</p>
<pre><code>a -&gt; (s -&gt; (b, s))</code></pre>
<p>Now, we encapsulate the tail <code>s -&gt; (b, s)</code> into a datatype</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>In this formulation, functions-with-state are expressed as functions <code>a -&gt; State s b</code>. We lost our obvious compositionality, but it’s not entirely gone! This composition expresses the entire monadicity of the State datatype:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="fu">return</span> x <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (x, s)</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="dt">State</span> m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (v, s') <span class="fu">=</span> m s </a>
<a class="sourceLine" id="cb3-4" title="4">                                  <span class="kw">in</span> runState (k v) s'</a></code></pre></div>
<p>To recap: the entire point of the monadic composition operator <code>&gt;&gt;=</code> above is to give us an abstraction of “passing state along the computations”. If a computation manipulates state, it must pass that mutated state around to the next computation, and to the next, otherwise our semantics would be all wrong. This is the essence of what monads do– they’re not <a href="https://blog.plover.com/prog/burritos.html">burritos</a> or whatever fancible food-item people think they are. They are <strong>ways to propagate effects through functions</strong>.</p>
<p>However, the monad is fairly obtuse to use by itself– often we write helper functions for the monad instance to allow access to the “internals” of the monad. For <code>State</code> 99.9% of the time we just want a way to fetch the current state, and to assign a state to be propagated. This usually gives rise to the two functions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">get ::</span> <span class="dt">State</span> s s</a>
<a class="sourceLine" id="cb4-2" title="2">get <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s, s)</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</a>
<a class="sourceLine" id="cb4-5" title="5">put s <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> ((), s)</a></code></pre></div>
<p>Plugging in the definitions above and running it through the monad instance gives you a sense of why these definitions are valid. From this, we can write various programs such as</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) ()</a>
<a class="sourceLine" id="cb5-4" title="4">fib n <span class="fu">=</span> forM_ [<span class="dv">0</span><span class="fu">..</span>n] loop</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" title="6">        loop m <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-7" title="7">            <span class="kw">if</span> m <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-8" title="8">            <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-9" title="9">                    put (<span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-10" title="10">                    <span class="fu">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-11" title="11">            <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-12" title="12">                    (a, b) <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb5-13" title="13">                    put (b, a <span class="fu">+</span> b)</a>
<a class="sourceLine" id="cb5-14" title="14">                    <span class="fu">return</span> b</a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="ot">fibo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-17" title="17">fibo n <span class="fu">=</span> forM_ [<span class="dv">0</span><span class="fu">..</span>n] <span class="fu">$</span> \m <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="fu">print</span> <span class="fu">$</span> <span class="fu">fst</span> (<span class="fu">snd</span> (runState (fib m) (<span class="dv">0</span>, <span class="dv">0</span>)))</a></code></pre></div>
<p>How nice.</p>
<h3 id="compositionality-and-monad-transformers">compositionality and monad transformers</h3>
<p>But the above looks undeniably wasteful– if all we wanted was to run <code>fibo 10</code> and print out the first 10 fibonacci numbers, why don’t we just print them out as opposed to the <code>return</code> command in <code>fib</code>? After all, <code>forM_</code> discards all those monadic return values and just propagates the effects (state in this case), and running <code>fibo</code> for printing merely runs through each <code>fib</code> wastefully again. But doing so naively results in an error!</p>
<p>Why is this the case? The crux is that monadic effects do not play well with one another, because monads do <strong>not</strong> compose. Unlike functors, the composition of two monads may no longer be a monad. The way I think it becomes clear is actually by thinking of monads as the monoid objects in the category of endofunctors of <span class="math inline">\(\text{Set}\)</span>, but people may differ…</p>
<p>To elucidate this, consider the category of monads over <span class="math inline">\(\text{Set}\)</span> as</p>
<p><span class="math display">\[ \text{Monad}_\text{Set} = \text{Mon}(\text{Fun}(\text{Set}, \text{Set})) \]</span></p>
<p>Here, a monad is given by an endofunctor <span class="math inline">\(F:\text{Set}\to\text{Set}\)</span> with natural transformations <span class="math inline">\(F\circ F\to F\)</span> and <span class="math inline">\(\text{id}_\text{Set}\to F\)</span>. When we compose two monads <span class="math inline">\(F\circ G\)</span>, how can we define the composition transformation <span class="math inline">\(F\circ G\circ F\circ G \to F \circ G\)</span>? This makes the crux of the matter clear: we need to propagate an effect corresponding to <span class="math inline">\(G\)</span> through the monad <span class="math inline">\(F\)</span>, <span class="math inline">\(F\circ G \rightsquigarrow G\circ F\)</span>.</p>
<p>This is the point behind a <strong>monad transformer</strong>, which reifies this propagation through the <code>lift</code> function. Simply said, a monad transformer is an operation that turns monads to monads. Usually such transformers operate on monads to imbue them with an <em>extra effect</em>, for example the <code>StateT</code> monad transformer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (a, s)</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">StateT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-6" title="6">        (v, s') <span class="ot">&lt;-</span> x s</a>
<a class="sourceLine" id="cb6-7" title="7">        runStateT (f v) s'</a></code></pre></div>
<p>The <code>lift</code> function is encoded in the <code>MonadTrans</code> typeclass</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    lift ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">StateT</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" title="5">    lift ma <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span> c <span class="ot">&lt;-</span> ma</a>
<a class="sourceLine" id="cb7-6" title="6">                                <span class="fu">return</span> (c, s)</a></code></pre></div>
<p>Along with encoding the usual <code>get/put</code> functions we get the second-take of the fibonacci function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">get ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">StateT</span> s m s</a>
<a class="sourceLine" id="cb8-2" title="2">get <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (s, s)</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">put ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m ()</a>
<a class="sourceLine" id="cb8-5" title="5">put s <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="fu">return</span> ((), s)</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="ot">fibT ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-8" title="8">fibT n <span class="fu">=</span> runStateT (forM_ [<span class="dv">0</span><span class="fu">..</span>n] loop) (<span class="dv">0</span>, <span class="dv">0</span>) <span class="fu">&gt;&gt;</span> <span class="fu">print</span> <span class="st">&quot;done!&quot;</span></a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" title="10">        loop m <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-11" title="11">            <span class="kw">if</span> m <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-12" title="12">            <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-13" title="13">                    put (<span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-14" title="14">                    lift <span class="fu">$</span> <span class="fu">print</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-15" title="15">            <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-16" title="16">                    (a, b) <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb8-17" title="17">                    put (b, a <span class="fu">+</span> b)</a>
<a class="sourceLine" id="cb8-18" title="18">                    lift <span class="fu">$</span> <span class="fu">print</span> b</a></code></pre></div>
<p>This looks nicer. But arguably more cumbersome. Isn’t there a better way to combine monadic (computational) effects?</p>
<h3 id="local-vs-global-coordinates">local vs global coordinates</h3>
<p>Monads explicitly tell us how to sequence computational effects, and this makes it difficult to combine them because of the amount of boilerplate needed to write them. But most of the time we don’t care about the implementation of the monad– we care about the interface it affords us, the <strong>operations</strong>, such as <code>get/put</code>.</p>
<p>Indeed, we can declare that any such abstraction that implements the state operations is “<code>State</code>”. And the State monad is merely a reification of this interface. For analogy reasons, we imagine that the <code>get/put</code> interface is the global “manifold” that we are trying to study, where the relations between the two interfaces constraining the “geometry” of such manifold. A monad instantiation of this interface corresponds to a local coordinatization of the manifold. The upshot of this view is the realization that there are many ways to instantiate this interface! This separation of effect operators from their interpretation via <em>handlers</em> is the theory of <strong>algebraic effects</strong>.</p>
<p>We wish to give an idea of the mathematical theory. The core slogan which starts this is the mathematical fact that:</p>
<p><span class="math display">\[ \text{&quot;Any adjunction gives rise to a monad.&quot;} \]</span></p>
<p>Recall that given an adjunction <span class="math inline">\(L: \mathcal{C}\to\mathcal{D}, R:\mathcal{D}\to\mathcal{C}\)</span>, we get a monad <span class="math inline">\(M=L\circ R:\mathcal{D}\to\mathcal{D}\)</span>. Let’s turn the question on it’s head and ask:</p>
<p><span class="math display">\[ \text{&quot;Does every monad come from an adjunction?&quot;} \]</span></p>
<p><strong>Yes.</strong> Let <span class="math inline">\(M\)</span> be a monad (which is the data of a monoid object in the category of endofunctors of <span class="math inline">\(\mathcal{C}\)</span>) and let <span class="math inline">\(\mathcal{C}^M\)</span> be the <strong>Eilenberg-Moore category</strong> of the monad: it is the category of <span class="math inline">\(M\)</span>-algebras <span class="math inline">\(\nu: M(A) \to A\)</span> for an object <span class="math inline">\(A\)</span> in <span class="math inline">\(\mathcal{C}\)</span>. The morphisms in this category are morphisms <span class="math inline">\(f: A\to B\)</span> in <span class="math inline">\(\mathcal{C}\)</span> satisfying the usual commutative squares.</p>
<p>There is a forgetful functor <span class="math inline">\(U:\mathcal{C}^M\to \mathcal{C}\)</span> given by forgetting the structure morphism <span class="math inline">\(\nu\)</span> and just returning <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[ U: (\nu: M(A) \to A) \mapsto A \]</span></p>
<p>What about the other direction? Given <span class="math inline">\(A\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, can we get a <span class="math inline">\(M\)</span>-algebra <span class="math inline">\(M(A)\to A\)</span>? Not always. But the monoid property of the monad gives <span class="math inline">\(M(A)\)</span> the structure of an <span class="math inline">\(M\)</span>-algebra for any <span class="math inline">\(A\)</span>, the so-called <strong>free <span class="math inline">\(M\)</span>-algebra</strong> <span class="math inline">\(M(M(A))\to M(A)\)</span>. This gives a free functor:</p>
<p><span class="math display">\[ F: A \mapsto (\nu_\text{free}: M(M(A))\to M(A)) \]</span></p>
<p>Hence, almost tautologically, we get our monad <span class="math inline">\(M\)</span> back as the composite of the free-forgetful adjunction <span class="math inline">\(M=U\circ F\)</span>! This conveys to us two lessons: 1) We should study the Eilenberg-Moore category as the “manifold of <span class="math inline">\(M\)</span>-effectful computations” and 2) we should study the free <span class="math inline">\(M\)</span>-algebras, as they are the building blocks of all our monadic effects. Indeed, any <span class="math inline">\(M\)</span>-algebra can be reconstructed from free <span class="math inline">\(M\)</span>-algebras via the 2-stage <strong>bar construction</strong>:</p>
<p><span class="math display">\[ (M^2 A, \mu_{M A})
  \stackrel{\overset{\mu_A}{\longrightarrow}}{\underset{M \nu}{\longrightarrow}}
  (M A, \mu_A)
  \stackrel{\nu}{\longrightarrow}
  (A,\nu)
  \,. \]</span> ty The above is a coequalizer (categorical colimit), and so it suffices to study the free <span class="math inline">\(M\)</span>-algebras. Pushing this down to the 2-categorical level we see the monad <span class="math inline">\(M\)</span> itself is a bar construction of <strong>free monads</strong>.</p>
<p>Hence a guise of algebraic effects can be seen in studying <em>free algebras over free monads</em>, which are equivalent to studying</p>
<p><span class="math display">\[ \text{trees of computational effects and folds of such trees} \]</span></p>
<h3 id="freer-monads">free(r) monads</h3>
<p>An algebra for a monad <span class="math inline">\(M(A)\to A\)</span> can be thought of as a way to capture a computational effect and return a value, i.e. an <strong>effect handler</strong>. Described this way, a free algebra for a free monad is a way to separate the semantics of an algebraic effect from its handler, i.e. its interpretation in reified values.</p>
<p>As above, free monads allow us to describe an operation we want to perform, and then promote these into abstract syntax trees. The data type for a free monad is given by</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="dt">Pure</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a </a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="dt">Impure</span><span class="ot"> ::</span> f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="ot">eta ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a </a>
<a class="sourceLine" id="cb9-8" title="8">eta <span class="fu">=</span> <span class="dt">Impure</span> <span class="fu">.</span> <span class="fu">fmap</span> <span class="dt">Pure</span> </a></code></pre></div>
<p>For example, we can describe ASTs for the <code>State</code> effect as</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="dt">FState</span> s <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">State</span> s)</a></code></pre></div>
<p>A value of type <code>FState s</code> is an abstract syntax tree with state counters in the nodes. Propagating effects through these trees is given by the monad instance:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="fu">return</span> <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="dt">Pure</span> a   <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k a </a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="dt">Impure</span> m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Impure</span> (<span class="fu">fmap</span> (<span class="fu">&gt;&gt;=</span> k) m)</a></code></pre></div>
<p>As a result, we can separate the ASTs (effects) from their interpreters (handlers):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">test ::</span> <span class="dt">FState</span> <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-2" title="2">test <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" title="3">    eta <span class="fu">$</span> put <span class="dv">10</span></a>
<a class="sourceLine" id="cb12-4" title="4">    x <span class="ot">&lt;-</span> eta get</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="fu">return</span> x</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="ot">interp ::</span> <span class="dt">FState</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-8" title="8">interp m <span class="fu">=</span> <span class="fu">fst</span> <span class="fu">$</span> run m <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-9" title="9">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" title="10">        run (<span class="dt">Pure</span> x)   s <span class="fu">=</span> (x, s)</a>
<a class="sourceLine" id="cb12-11" title="11">        run (<span class="dt">Impure</span> m) s <span class="fu">=</span> <span class="kw">let</span> (m0, s0) <span class="fu">=</span> runState m s</a>
<a class="sourceLine" id="cb12-12" title="12">                           <span class="kw">in</span> run m0 s0</a></code></pre></div>
<p>Here <code>interp</code> is a <code>FState</code>-algebra. However, this is unsatisfactory: we wanted to provide an <em>interface</em> of operations for the state effect, such as <code>get/put</code> and then promote that into abstract syntax trees. So we start with the interface</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">data</span> <span class="dt">StateF</span> s a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">StateF</span> s a</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="dt">Put</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">StateF</span> s ()</a></code></pre></div>
<p>And try to create the free monad from it:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">type</span> <span class="dt">FFState</span> s <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">StateF</span> s)</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="fu">&gt;&gt;&gt;</span> <span class="dt">ERROR</span><span class="fu">:</span> <span class="dt">StateF</span> s is <span class="dt">NOT</span> a functor<span class="fu">!</span></a></code></pre></div>
<p>Here, <code>StateF</code> is described as a GADT, which can’t be promoted to a functor instance! After all, where would <code>Put 10</code> be mapped to?</p>
<p>But category theory saves us a bit here. We have a not-yet-functor <code>StateF s</code> and we want to “thicken” it to one, in the minimal way. In other words, we are looking for the <em>best approximation to the problem of finding a functor</em> <code>StateFF s : Type -&gt; Type</code> <em>extending</em> <code>StateF</code>. This is known as a <strong>left Kan extension</strong>. To read more about it, we refer to the <a href="https://ncatlab.org/nlab/show/Kan+extension">nLab</a> article about it.</p>
<p>How do we define the Kan extension? Let’s abstract the situation a bit. Suppose you had a not-yet-functor <span class="math inline">\(F:\mathcal{C}\to\mathcal{D}\)</span> (by this we mean, <span class="math inline">\(F\)</span> is only defined on a subpart of <span class="math inline">\(\mathcal{C}\)</span>) and you wanted to extend it to an actual functor <span class="math inline">\(\text{Lan}_\text{id} F:\mathcal{C}\to\mathcal{D}\)</span>.</p>
<p>Let <span class="math inline">\(c\)</span> be an object in <span class="math inline">\(\mathcal{C}\)</span>. Where would it go? If it were in the subpart of <span class="math inline">\(C\)</span> that <span class="math inline">\(F\)</span> is defined on, call it <span class="math inline">\(\hat{\mathcal{C}}\)</span>, we simply send it to <span class="math inline">\(F(c)\)</span>. What if it isn’t? Simple idea: if <span class="math inline">\(F\)</span> isn’t defined on <span class="math inline">\(c\)</span>, we can instead look at an object <em>close to</em> <span class="math inline">\(c\)</span> where <span class="math inline">\(F\)</span> is defined, and use that as our answer. Obviously, that isn’t great, because we have to ask “which object close to <span class="math inline">\(c\)</span> do we choose?” In category theory, we don’t make choices. We take them all!</p>
<p>For any object <span class="math inline">\(c'\)</span> in <span class="math inline">\(\hat{\mathcal{C}}\)</span> with a map to <span class="math inline">\(c\)</span>, <span class="math inline">\(c'\to c\)</span>, we look at the value <span class="math inline">\(F(c')\)</span>. This gives us a large graph of values in <span class="math inline">\(\mathcal{D}\)</span>– if <span class="math inline">\(F\)</span> were defined on <span class="math inline">\(c\)</span>, they would all have maps <span class="math inline">\(F(c')\to F(c)\)</span>. But since it isn’t, we don’t have these maps. The left Kan extension is then the best approximation to this map, which is also known as the <em>colimit</em>:</p>
<p><span class="math display">\[ (\text{Lan}_\text{id} F)(c) = \text{colim}^{\text{Hom}_\mathcal{C}(- ,c)} F
  \,.
\]</span></p>
<p>To write this in Haskell, it is convenient to encode this as a coend:</p>
<p><span class="math display">\[ (\text{Lan}_\text{id} F)(c) \simeq \int^{c' \in C} \text{Hom}_\mathcal{C}(c',c)\otimes F(c') \]</span></p>
<p>This allows us to write the left Kan extension as</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">data</span> <span class="dt">Lan</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="dt">Lan</span><span class="ot"> ::</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Lan</span> f a</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Lan</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="fu">fmap</span> k (<span class="dt">Lan</span> fx h) <span class="fu">=</span> <span class="dt">Lan</span> fx (k <span class="fu">.</span> h)</a></code></pre></div>
<p><strong>Upshot:</strong> Given the interface, we get a new <strong>freer monad</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">type</span> <span class="dt">FFState</span> s <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">Lan</span> (<span class="dt">State</span> s))</a></code></pre></div>
<p>The type constructor <code>Free Lan</code> when desugared gives the (non-GADT!) datatype</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">data</span> <span class="dt">FFree</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="dt">FPure</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">FFree</span> f a</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="dt">FImpure</span><span class="ot"> ::</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> <span class="dt">FFree</span> f a) <span class="ot">-&gt;</span> <span class="dt">FFree</span> f a</a></code></pre></div>
<p>In this, the type signature for <code>FImpure</code> describes effects clearly: it’s a continuation! From this, the monad instance for <code>FFree f</code> is like that of a free monad:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">FFree</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="fu">return</span> <span class="fu">=</span> <span class="dt">FPure</span></a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="dt">FPure</span> x       <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="dt">FImpure</span> fx ct <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">FImpure</span> fx (\x <span class="ot">-&gt;</span> (ct x) <span class="fu">&gt;&gt;=</span> k)</a></code></pre></div>
<p>Notice that we don’t need <code>f</code> to be a functor anymore!</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
