<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Profunctors are generalized functors - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Profunctors are generalized functors</h1>
            <article>
    <section class="header">
        Posted on January 22, 2020
        
    </section>
    <section>
        <p><strong>Note: This blog post isn’t finished yet. Read on with caution.</strong></p>
<p>There’s a thread of connections that I’ve been curiously following for a few weeks now, but I’ve not been able to grasp it fully. I’ve heard people say at various Haskell meetups that there are relations between lenses/prisms, profunctors, and traversals. I don’t really know what lenses are, and traversals seem too different to me from profunctors.</p>
<p>As far as I can tell, <code>Traversable</code> is a type class that endows a data container/functor the ability to “walk along” itself while processing a computational effect (which comes from the fact that <code>Traversable</code> instances subclass <code>Applicative</code>s). How in the world does this have anything to do with a “pro”functor?</p>
<p>In this post, I’m going to look over what profunctors are in the mathematical sense, and in later posts I’ll hopefully try and enlighten myself as to the connections to the functional programming perspective.</p>
<h3 id="into-category-theory">into category theory</h3>
<p>I warn that this will not be an introductory post on category theory. Those who are interested in definitions and introductory material should look at the <a href="https://ncatlab.org/nlab/show/HomePage">nLab</a> and <a href="https://www.amazon.com/Category-Theory-Context-Aurora-Originals/dp/048680903X/ref=sr_1_1?keywords=categories+in+context&amp;qid=1579664959&amp;sr=8-1">Riehl’s book</a>.</p>
<p>First lets talk about regular functions between topological spaces <span class="math inline">\(f:X\to Y\)</span>. In topology it’s sort of an imperative to try to geometricize any existing notion relating other topological notions, and this includes functions themselves (incidentally, it’s like the functional programmer’s pragma of trying to lift anything to a first-class notion). So we are seeking generalized ways to look at <span class="math inline">\(f\)</span>. One obvious way is to identify the function with it’s graph <span class="math inline">\(\hat{f}\subset X\times Y\)</span>.</p>
<p>One way to generalize functions <span class="math inline">\(f:X\to Y\)</span> then is to treat a “generalized function” as a function over the product space <span class="math inline">\(X\times Y\)</span> (recursive, I know!). Since we don’t want to be this recursive, we’ll treat this in the sense of algebraic geometry, and say that a generalized function is a section of a vector bundle over the product <span class="math inline">\(X\times Y\)</span>. In this language, the original functions we are talking about are sections of the trivial line bundle with support over the graph of these functions. (I won’t be pedantic here, you can trace the definitions for yourselves if you’re unsatisfied).</p>
<p>The upshot of that in algebraic geometry is that such vector bundles give rise to <em>bimodules</em>. Bimodules can be thought of as “variating families of maps”– as a poignant example, imaging taking a section of a vector bundle over <span class="math inline">\(X\times Y\)</span> (say, <span class="math inline">\(\rho: E \to X\times Y\)</span>) and vary a point <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span>. The preimages <span class="math inline">\(\rho^{-1}({x}\times Y)\)</span> form a varying family of functions, apt for the name “generalized function”.</p>
<p>In my opinion, the single most important theorem about bimodules is the <a href="https://ncatlab.org/nlab/show/Eilenberg-Watts+theorem">Eilenberg-Watts theorem</a>. The version we care about describes an equivalence of categories between bimodules and colimit-preserving functors between module categories:</p>
<p><span class="math display">\[ {}_R \text{Mod}_{S} \stackrel{\simeq}{\to} \text{Func}_{coc}(\text{Mod}_R, \text{Mod}_S) \]</span></p>
<p>From this we start to understand what a profunctor is as a “generalized functor”: it should be a “bimodule over enriched categories”, or <strong>equivalently</strong> it should be a colimit-preserving functor between “categories containing all infinite constructions” (<span class="math inline">\(\text{Mod}_R\)</span> is a <em>complete and cocomplete</em> category).</p>
<h3 id="bimodules-in-categories">bimodules in categories</h3>
<p>So lets unwind what these are. Since we are in the setting of enriched category theory, let <span class="math inline">\(V\)</span> be a closed monoidal category (if we’re in the world of Haskell, <span class="math inline">\(V\)</span> would be cartesian closed, but in a linear type situation, we take <span class="math inline">\(V\)</span> to be more general). For a category <span class="math inline">\(C\)</span> enriched over <span class="math inline">\(V\)</span>, a <span class="math inline">\(C\)</span>-<em>module</em> can be defined as a functor <span class="math inline">\(\rho: C\to V\)</span>. A <span class="math inline">\(C\)</span>-<span class="math inline">\(D\)</span> <em>bimodule</em> is an enriched functor</p>
<p><span class="math display">\[ C^{op}\otimes D\to V \]</span></p>
<p>When <span class="math inline">\(V\)</span> is the category of sets (or types Hask), this is a profunctor.</p>
<p>If you’re confused by this, keep a concrete example in your head: let <span class="math inline">\(V\)</span> be the category <span class="math inline">\(\text{Vect}^{\text{fin}}\)</span> of finite-dimensional vector spaces over a field <span class="math inline">\(k\)</span>, and let <span class="math inline">\(C\)</span> be any <span class="math inline">\(V\)</span>-enriched category with one object. Then a <span class="math inline">\(C\)</span>-module in the above sense is exactly a <span class="math inline">\(k\)</span>-algebra in the classical sense, and a <span class="math inline">\(C\)</span>-<span class="math inline">\(D\)</span> bimodule here is a bimodule in the classical sense.</p>
<p>Another example of a profunctor is the hom functor <span class="math inline">\(\text{Hom}_C(-,-): C^{op}\times C\to \text{Set}\)</span>. This example makes it clear that a profunctor is a “varying family of functors”, where varying an object <span class="math inline">\(c\)</span> of <span class="math inline">\(C\)</span> gives rise to functors <span class="math inline">\(\text{Hom}_C(c,-): C\to\text{Set}\)</span>.</p>
<h3 id="profunctors-are-functors-between-presheaves">profunctors are functors between presheaves</h3>
<p>How do we get to our Eilenberg-Watts description of profunctors? Our favorite trick– the Yoneda lemma. What does the Yoneda lemma say? For our purposes, it guarantees us an embedding of any (small) category <span class="math inline">\(C\)</span> into its category of presheaves <span class="math inline">\(\text{PShv}(C) = \text{Func}(C^{op}, \text{Set})\)</span>. Hence for any old functor <span class="math inline">\(F:C\to D\)</span>, we get a composition</p>
<p><span class="math display">\[ C \stackrel{F}{\longrightarrow} D \stackrel{Yoneda}{\longrightarrow} \text{PShv}(D) \]</span></p>
<p>which by adjunction gives rise to our first definition of a profunctor. Continuing from here, another guarantee we have here is that as <span class="math inline">\(\text{PShv}(D)\)</span> is cocomplete, by Kan extension we can lift our composition to a functor between the cocompletion of <span class="math inline">\(C\)</span> (which happens to be <span class="math inline">\(\text{PShv(C)}\)</span>!) and <span class="math inline">\(\text{PShv}(D)\)</span> that preserves colimits:</p>
<p><span class="math display">\[ \text{PShv}(C) \to \text{PShv}(D) \]</span></p>
<p>This is the Eilenberg-Watts theorem! And also, this is a strikingly nice categorical description of a profunctor in terms of colimit properties.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
