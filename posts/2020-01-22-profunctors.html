<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Profunctors are generalized functors - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Profunctors are generalized functors</h1>
            <article>
    <section class="header">
        Posted on January 22, 2020
        
    </section>
    <section>
        <p><strong>Note: This blog post is still a rough draft. Read on with caution.</strong></p>
<p>There’s a thread of connections that I’ve been curiously following for a few weeks now, but I’ve not been able to grasp it fully. I’ve heard people say at various Haskell meetups that there are relations between lenses/prisms, profunctors, and traversals. I don’t really know what lenses are, and traversals seem too different to me from profunctors.</p>
<p>As far as I can tell, <code>Traversable</code> is a type class that endows a data container/functor the ability to “walk along” itself while processing a computational effect (which comes from the fact that <code>Traversable</code> instances subclass <code>Applicative</code>s). How in the world does this have anything to do with a “pro”functor?</p>
<p>In this post, I’m going to look over what profunctors are in the mathematical sense, and in later posts I’ll hopefully try and enlighten myself as to the connections to the functional programming perspective.</p>
<h3 id="into-category-theory">into category theory</h3>
<p>I warn that this will not be an introductory post on category theory. Those who are interested in definitions and introductory material should look at the <a href="https://ncatlab.org/nlab/show/HomePage">nLab</a> and <a href="https://www.amazon.com/Category-Theory-Context-Aurora-Originals/dp/048680903X/ref=sr_1_1?keywords=categories+in+context&amp;qid=1579664959&amp;sr=8-1">Riehl’s book</a>.</p>
<p>First lets talk about regular functions between topological spaces <span class="math inline">\(f:X\to Y\)</span>. In topology it’s sort of an imperative to try to geometricize any existing notion relating other topological notions, and this includes functions themselves (incidentally, it’s like the functional programmer’s pragma of trying to lift anything to a first-class notion). So we are seeking generalized ways to look at <span class="math inline">\(f\)</span>. One obvious way is to identify the function with it’s graph <span class="math inline">\(\hat{f}\subset X\times Y\)</span>.</p>
<p>One way to generalize functions <span class="math inline">\(f:X\to Y\)</span> then is to treat a “generalized function” as a function over the product space <span class="math inline">\(X\times Y\)</span> (recursive, I know!). Since we don’t want to be this recursive, we’ll treat this in the sense of algebraic geometry, and say that a generalized function is a section of a vector bundle over the product <span class="math inline">\(X\times Y\)</span>. In this language, the original functions we are talking about are sections of the trivial line bundle with support over the graph of these functions. (I won’t be pedantic here, you can trace the definitions for yourselves if you’re unsatisfied).</p>
<p>The upshot of that in algebraic geometry is that such vector bundles give rise to <em>bimodules</em>. Bimodules can be thought of as “variating families of maps”– as a poignant example, imaging taking a section of a vector bundle over <span class="math inline">\(X\times Y\)</span> (say, <span class="math inline">\(\rho: E \to X\times Y\)</span>) and vary a point <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span>. The preimages <span class="math inline">\(\rho^{-1}({x}\times Y)\)</span> form a varying family of functions, apt for the name “generalized function”.</p>
<p>In my opinion, the single most important theorem about bimodules is the <a href="https://ncatlab.org/nlab/show/Eilenberg-Watts+theorem">Eilenberg-Watts theorem</a>. The version we care about describes an equivalence of categories between bimodules and colimit-preserving functors between module categories:</p>
<p><span class="math display">\[ {}_R \text{Mod}_{S} \stackrel{\simeq}{\to} \text{Func}_{coc}(\text{Mod}_R, \text{Mod}_S) \]</span></p>
<p>From this we start to understand what a profunctor is as a “generalized functor”: it should be a “bimodule over enriched categories”, or <strong>equivalently</strong> it should be a colimit-preserving functor between “categories containing all infinite constructions” (<span class="math inline">\(\text{Mod}_R\)</span> is a <em>complete and cocomplete</em> category).</p>
<h3 id="bimodules-in-categories">bimodules in categories</h3>
<p>So lets unwind what these are. Since we are in the setting of enriched category theory, let <span class="math inline">\(V\)</span> be a closed monoidal category (if we’re in the world of Haskell, <span class="math inline">\(V\)</span> would be cartesian closed, but in a linear type situation, we take <span class="math inline">\(V\)</span> to be more general). For a category <span class="math inline">\(C\)</span> enriched over <span class="math inline">\(V\)</span>, a <span class="math inline">\(C\)</span>-<em>module</em> can be defined as a functor <span class="math inline">\(\rho: C\to V\)</span>. A <span class="math inline">\(C\)</span>-<span class="math inline">\(D\)</span> <em>bimodule</em> is an enriched functor</p>
<p><span class="math display">\[ C^{op}\otimes D\to V \]</span></p>
<p>When <span class="math inline">\(V\)</span> is the category of sets (or types Hask), this is a profunctor.</p>
<p>If you’re confused by this, keep a concrete example in your head: let <span class="math inline">\(V\)</span> be the category <span class="math inline">\(\text{Vect}^{\text{fin}}\)</span> of finite-dimensional vector spaces over a field <span class="math inline">\(k\)</span>, and let <span class="math inline">\(C\)</span> be any <span class="math inline">\(V\)</span>-enriched category with one object. Then a <span class="math inline">\(C\)</span>-module in the above sense is exactly a <span class="math inline">\(k\)</span>-algebra in the classical sense, and a <span class="math inline">\(C\)</span>-<span class="math inline">\(D\)</span> bimodule here is a bimodule in the classical sense.</p>
<p>Another example of a profunctor is the hom functor <span class="math inline">\(\text{Hom}_C(-,-): C^{op}\times C\to \text{Set}\)</span>. This example makes it clear that a profunctor is a “varying family of functors”, where varying an object <span class="math inline">\(c\)</span> of <span class="math inline">\(C\)</span> gives rise to functors <span class="math inline">\(\text{Hom}_C(c,-): C\to\text{Set}\)</span>.</p>
<h3 id="profunctors-are-functors-between-presheaves">profunctors are functors between presheaves</h3>
<p>How do we get to our Eilenberg-Watts description of profunctors? Our favorite trick– the Yoneda lemma. What does the Yoneda lemma say? For our purposes, it guarantees us an embedding of any (small) category <span class="math inline">\(C\)</span> into its category of presheaves <span class="math inline">\(\text{PShv}(C) = \text{Func}(C^{op}, \text{Set})\)</span>. Hence for any old functor <span class="math inline">\(F:C\to D\)</span>, we get a composition</p>
<p><span class="math display">\[ C \stackrel{F}{\longrightarrow} D \stackrel{Yoneda}{\longrightarrow} \text{PShv}(D) \]</span></p>
<p>which by adjunction gives rise to our first definition of a profunctor. Continuing from here, another guarantee we have here is that as <span class="math inline">\(\text{PShv}(D)\)</span> is cocomplete, by Kan extension we can lift our composition to a functor between the cocompletion of <span class="math inline">\(C\)</span> (which happens to be <span class="math inline">\(\text{PShv(C)}\)</span>!) and <span class="math inline">\(\text{PShv}(D)\)</span> that preserves colimits:</p>
<p><span class="math display">\[ \text{PShv}(C) \to \text{PShv}(D) \]</span></p>
<p>This is the Eilenberg-Watts theorem! And also, this is a strikingly nice categorical description of a profunctor in terms of colimit properties.</p>
<h3 id="composition-of-profunctors">composition of profunctors</h3>
<p>If we have functors, we’d like to compose them. If we have profunctors, we’d like to compose them too. How?</p>
<p>Let’s fix an example. Let <span class="math inline">\(C\)</span> be a category, and consider the <span class="math inline">\(\text{Hom}\)</span> profunctor. How would we compute the composition <span class="math inline">\(\text{Hom}_C\circ\text{Hom}_C\)</span>? Let <span class="math inline">\(a, b\)</span> be two objects of <span class="math inline">\(C\)</span>, and consider the value of the composition <span class="math inline">\((\text{Hom}_C\circ\text{Hom}_C)(a, b)\)</span>, which is a set.</p>
<p>Naturally, we’d think of the elements in this set to correspond to compositions of original functions (afterall, that’s what <span class="math inline">\(\text{Hom}_C(-,-)\)</span> represents):</p>
<p><span class="math display">\[ a \to ? \to b \]</span></p>
<p>But which object “<span class="math inline">\(?\)</span>” does the map pass through? Just like Feynman’s path integrals, we could let the function pass through anything! In essence, we can consider all the possible ways to get from <span class="math inline">\(a \to b\)</span> while passing through another object, which is represented by the coproduct</p>
<p><span class="math display">\[ \coprod_{d\in C} \text{Hom}_C(a,d)\times\text{Hom}_C(d,b) \]</span></p>
<p>This isn’t the true composition however, because there are a lot of equivalent ways to get from <span class="math inline">\(a\to b\)</span> through different objects! In essence, we will try to identify as many “commutative diagrams” as possible to get a lossless compression of the above set. Mathematically, this is a <strong>coend</strong>, which is a kind of Kan extension.</p>
<p>In general, for profunctors <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>, the composition is given by the coend:</p>
<p><span class="math display">\[ G \circ F := \int^{d \in D} F(d,-)\otimes G(-,d) \]</span></p>
<p>where here, the <span class="math inline">\(\otimes\)</span> denotes the monoidal structure of the enrichment category. As above, a coend should be thought of as all the ways to “create a varying family of functors by using the family of functors defined by <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>”.</p>
<h3 id="hochschild-homology">hochschild homology?</h3>
<p>Finally, I’d like to look at another way to describe generalized functions. Another description of the graph <span class="math inline">\(\hat{f}\)</span> of a function <span class="math inline">\(f:X\to Y\)</span> is as a <strong>correspondence</strong> or <strong>span</strong>:</p>
<p><span class="math display">\[ X \leftarrow Z \to Y \]</span></p>
<p>If the category we’re working in has (homotopy) pullbacks (a kind of colimit), we can compose such spans using them. In particular, if we’re working in a derived/homotopical setting, given a span <span class="math inline">\(X\leftarrow A\to X\)</span>, it’s self-composition is given by the derived tensor product</p>
<p><span class="math display">\[ X \leftarrow \text{Spec}(A\otimes^{\mathbb{L}}_X A) \to X \]</span></p>
<p>The object <span class="math inline">\(A\otimes^{\mathbb{L}}_X A\)</span> is known as the <strong>Hochschild homology</strong> of the bimodule <span class="math inline">\(A\)</span> over <span class="math inline">\(X\)</span>, and is a central object of study in noncommutative algebraic geometry and algebraic topology. It would be interesting to see how this object makes its way into computer science as these other tidbits of category theory already has.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
