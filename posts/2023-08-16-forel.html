<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" type="image/x-icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Online learning and FoReL - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Online learning and FoReL</h1>
            <article>
    <section class="header">
        Posted on August 16, 2023
        
            by Calvin
        
    </section>
    <section>
        <p><strong>Note: This blog post is still a rough draft. Read on with caution.</strong></p>
<p>In part 2 of our unthemed dive into the reinforcement learning literature, we will be taking a look at online (convex) optimization and some reinforcement learning algorithms that came out of it, applied to imperfect-information zero-sum games.</p>
<p>The last post focused on counterfactual regret minimization, which was also an online algorithm for choosing the optimal strategies for an agent. The success of counterfactual regret minimization came from its strong theoretical guarantees of sublinear regret growth, along with its generality. As such, it seems fitting to start with a general overview of the ideas behind online optimization and see what other ideas came out of it that could be fruitful for future AIs.</p>
<h3 id="online-learning">online learning</h3>
<p>In machine learning, online learning is the process of continuously adapting and making decisions from streams of information: at each point in a time <span class="math inline">\(t\)</span>, an online learning algorithm is given an informational signal <span class="math inline">\(x_t\)</span> from a space <span class="math inline">\(\mathcal{X}\)</span>, and decides on an action <span class="math inline">\(a_t\in\mathcal{A}\)</span> to perform. After their decision, the environment/opponent chooses a loss function <span class="math inline">\(\ell^t\)</span> and causes the agent to suffer a loss <span class="math inline">\(\ell^t(x_t, a_t)\)</span>. The algorithm learns from this loss and updates its processes for the next time.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_timesteps):</a>
<a class="sourceLine" id="cb1-2" title="2">    signal_t <span class="op">=</span> env.receive_signal()</a>
<a class="sourceLine" id="cb1-3" title="3">    action_t <span class="op">=</span> learner.decide(signal_t)</a>
<a class="sourceLine" id="cb1-4" title="4">    loss_t <span class="op">=</span> env.receive_loss()</a>
<a class="sourceLine" id="cb1-5" title="5">    loss <span class="op">=</span> loss_t(signal_t, action_t)</a>
<a class="sourceLine" id="cb1-6" title="6">    learner.suffer(loss)</a></code></pre></div>
<p>The goal of the learner is to minimize their <strong>regret</strong></p>
<p><span class="math display">\[ R^T = \max_{a^*\in\mathcal{A}}\left\{\sum_{t=1}^T\ell^t(x_t, a^*)\right\} - \sum_{t=1}^T\ell^t(x_t, a_t) \]</span></p>
<p>We call such an online learning setting <strong>learnable</strong> if we can achieve sublinear regret in <span class="math inline">\(T\)</span>.</p>
<p>Let us give a vibe for the field with an example. Consider the <span class="math inline">\(n\)</span>-<em>expert opinion</em> setting, where we at each time step we are trying to perform a binary action, i.e. <span class="math inline">\(a_t\in\mathcal{A}=\{0, 1\}\)</span>. To inform us on what action to take, we listen to <span class="math inline">\(n\)</span> “experts”, which in our setting is a vector of 0’s and 1’s <span class="math inline">\(x_t\in\mathcal{X}=\{0,1\}^n\)</span>. After the learner takes their binary action, the true answer in <span class="math inline">\(\{0,1\}\)</span> is revealed and the loss is given by the 0-1 loss</p>
<p><span class="math display">\[  
\begin{equation}
    \ell^t(x_t, a_t) = 
    \begin{cases}
        1 &amp; \text{if } a_t\text{ is correct answer}\\
        0 &amp; \text{otherwise}
    \end{cases}
\end{equation}
\]</span></p>
<p>We can then see that the regret <span class="math inline">\(R^T\)</span> is merely the <strong>number of mistakes</strong> made by the learner after <span class="math inline">\(T\)</span> attempts.</p>
<p>In this <a href="https://www.sciencedirect.com/science/article/pii/S0890540184710091?via%3Dihub">paper</a> of Littlestone-Warmuth, a simple algorithm called the <strong>weighted majority algorithm</strong> is introduced that achieves sublinear regret for this problem. We maintain a list of weights <span class="math inline">\(w_1,...,w_n\)</span>, one for each expert, and we vote on an action based on weighted majority of the experts– that is, for the expert opinions <span class="math inline">\((x_1,...,x_n)\in\{0,1\}^n\)</span>, we vote 1 if</p>
<p><span class="math display">\[  \sum_{i:x_i=1} w_i \ge \sum_{i:x_i=0} w_i \]</span></p>
<p>and 0 otherwise.</p>
<p>Once we receive the correct answer, we penalize each incorrect expert by multiplying their weight by 0.5. In code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">class</span> WeightedMajority(Learner):</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_experts: <span class="bu">int</span>):</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="va">self</span>.num_experts <span class="op">=</span> num_experts</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="co"># initialize weights of experts to 1.0</span></a>
<a class="sourceLine" id="cb2-7" title="7">        <span class="va">self</span>.weights <span class="op">=</span> np.repeat(<span class="fl">1.0</span>, num_experts)</a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="va">self</span>.last_opinions <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb2-9" title="9">    </a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="kw">def</span> decide(<span class="va">self</span>, opinions: np.ndarray) <span class="op">-&gt;</span> <span class="bu">int</span>:</a>
<a class="sourceLine" id="cb2-11" title="11">        <span class="co"># weighted majority vote</span></a>
<a class="sourceLine" id="cb2-12" title="12">        total_weight_0 <span class="op">=</span> np.<span class="bu">sum</span>(<span class="va">self</span>.weights <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> opinions))</a>
<a class="sourceLine" id="cb2-13" title="13">        total_weight_1 <span class="op">=</span> np.<span class="bu">sum</span>(<span class="va">self</span>.weights <span class="op">*</span> opinions)</a>
<a class="sourceLine" id="cb2-14" title="14">        <span class="va">self</span>.last_opinions <span class="op">=</span> opinions</a>
<a class="sourceLine" id="cb2-15" title="15">        <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> total_weight_1 <span class="op">&gt;=</span> total_weight_0 <span class="cf">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="kw">def</span> suffer(<span class="va">self</span>, loss: <span class="bu">int</span>):</a>
<a class="sourceLine" id="cb2-18" title="18">        <span class="co"># here, loss is the &quot;correct answer&quot; in {0, 1}</span></a>
<a class="sourceLine" id="cb2-19" title="19">        wrong_experts <span class="op">=</span> <span class="va">self</span>.weights[<span class="va">self</span>.last_opinions <span class="op">!=</span> loss]</a>
<a class="sourceLine" id="cb2-20" title="20">        wrong_experts <span class="op">*=</span> <span class="fl">0.5</span></a>
<a class="sourceLine" id="cb2-21" title="21">        <span class="va">self</span>.weights[<span class="va">self</span>.last_opinions <span class="op">!=</span> loss] <span class="op">=</span> wrong_experts</a></code></pre></div>
<p>The <em>main theorem</em> of Littlestone-Warmuth is a regret analysis of this learning algorithm: the number of mistakes <span class="math inline">\(R^T\)</span> made by the weighted majority learner is bounded above by</p>
<p><span class="math display">\[ R^T \le 2.41(m + \log_2{n}) \]</span></p>
<p>where <span class="math inline">\(m\)</span> is the number of mistakes made by the best expert so far.</p>
<p><strong>Proof:</strong> This is fairly straightforward. Let <span class="math inline">\(W\)</span> be the total weight of all experts (so initially <span class="math inline">\(W=n\)</span>). If the learner makes a mistake, that means that more than half the total weight is on the wrong experts, so that chunk will be halved. As a consequence, we lose at least a 1/4th of our total weight. So</p>
<p><span class="math display">\[ W \le n(3/4)^M \]</span></p>
<p>where <span class="math inline">\(M\)</span> is the total number of mistakes made (above we called it <span class="math inline">\(R^T\)</span>).</p>
<p>On the contrary, if our best expert made <span class="math inline">\(m\)</span> mistakes, it’s weight is <span class="math inline">\(1/2^m\)</span> and so <span class="math inline">\(W\ge 1/2^m\)</span> at least. Combining the two gives</p>
<p><span class="math display">\[ 1/2^m \le n(3/4)^M \]</span></p>
<p>which rearranging gives the regret bound. <span class="math inline">\(\square\)</span></p>
<p>It is often the case that many algorithms in computer science are enhanced by introducing randomness. Applying it to this situation will miraculously give a better regret bound! Here, instead of weighted majority vote, we normalize the weights into <em>probabilities</em> and choose as our action the opinion of a randomly chosen expert. We also then multiply the weights of all wrong experts by <span class="math inline">\(\beta\)</span>, where <span class="math inline">\(\beta\)</span> is some hyperparameter we can tune the algorithm with.</p>
<p>Via a similar argument, we can prove the regret bound</p>
<p><span class="math display">\[ R^T \le \frac{m\log(1/\beta) + \log n}{1-\beta} \]</span></p>
<p>where, again <span class="math inline">\(m\)</span> is the number of mistakes made by the best expert so far.</p>
<h3 id="convex-optimization">convex optimization</h3>
<p>A special case that we will focus on is the setting of <strong>online convex optimization</strong>. Here, we receive <strong>no</strong> signals <span class="math inline">\(x_t\)</span> from the environment, and instead our “actions” will be points in a convex domain <span class="math inline">\(a_t\in\mathcal{K}\)</span>. The loss here will be given by an arbitrary convex function <span class="math inline">\(f_t\)</span>, and so the goal of our convex optimizer is to minimize the regret term</p>
<p><span class="math display">\[ R^T = \max_{a^*\in\mathcal{K}}\left\{\sum_{t=1}^T f_t(a^*)\right\} - \sum_{t=1}^T f_t(a_t) \]</span></p>
<p>Our goal in this post is to introduce and derive some important algorithms for solving the online convex optimization problem, and apply these algorithms to game-theoretic solutions in modern machine learning.</p>
<p>Online convex optimization in pseudocode is given by:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_timesteps):</a>
<a class="sourceLine" id="cb3-2" title="2">    x_t <span class="op">=</span> learner.generate()</a>
<a class="sourceLine" id="cb3-3" title="3">    f_t <span class="op">=</span> env.receive_loss()</a>
<a class="sourceLine" id="cb3-4" title="4">    loss <span class="op">=</span> f_t(x_t)</a>
<a class="sourceLine" id="cb3-5" title="5">    learner.suffer(loss)</a></code></pre></div>
<p>which is similar to the general online learning situation above. In OCO we are trying to compute the <em>offline optimum</em></p>
<p><span class="math display">\[ \min_{x\in\mathcal{K}}\sum_{t=1}^T f_t(x) \]</span></p>
<p>(which is equivalent to getting sublinear regret), where our <span class="math inline">\(f_t\)</span> is coming from a potentially constrained space of functions <span class="math inline">\(\mathcal{F}\)</span>. The <strong>goal</strong> is to, in a generic way, get a regret bound of the form</p>
<p><span class="math display">\[ R^T \le \mathcal{O}_{\mathcal{K},\mathcal{F}}(\sqrt{T}) \]</span></p>
<p>Like in the last section, we will first describe an online convex optimization problem inspired by the expert opinion problem: here we have <span class="math inline">\(n\)</span> experts, with a goal to best utilize the opinions of the experts in order to minimize a linear loss.</p>
<p>At time <span class="math inline">\(t=1,2,...\)</span> we need to decide <span class="math inline">\(x_t\in\Delta^n\)</span> (where <span class="math inline">\(\Delta^n\)</span> is the probability simplex, see last post), probabilities for following the advice, i.e.</p>
<p><span class="math display">\[  x_{t,i}=\text{probability of listening to expert }i\text{ at time }t \]</span></p>
<p>Let <span class="math inline">\(\ell^t\)</span> be the loss vector where</p>
<p><span class="math display">\[ \ell^t_i=\text{loss of listening to expert }i\text{ at time }t \]</span></p>
<p>Our expected loss is then</p>
<p><span class="math display">\[ \sum_{i=1}^n x_{t,i}\ell^t_i = \langle x_t, \ell^t\rangle \]</span></p>
<p>This is the case of online convex optimization where at each time <span class="math inline">\(t\)</span>, the generated point is <span class="math inline">\(x_t\in\Delta^n\)</span> (note that the probability simplex is convex!) and the linear convex loss is given by <span class="math inline">\(f_t(x)=\langle x_t, \ell^t\rangle\)</span>.</p>
<p>The learning algorithm we will use for this problem is known as <strong>multiplicative weights</strong>.</p>
<h3 id="multiplicative-weights">multiplicative weights</h3>
<p>We give here a statistical physics approach to a no-regret algorithm for the expert advice problem.</p>
<p>Focusing on a single expert <span class="math inline">\(i\)</span>, call the cumulative loss incurred by this expert at time <span class="math inline">\(t-1\)</span> to be the <em>energy</em></p>
<p><span class="math display">\[ E_t(i) = \sum_{k=1}^{t-1}\ell_i^k \]</span></p>
<p>So at time <span class="math inline">\(t\)</span>, the learner knows <span class="math inline">\(E_t(i)\)</span> for each <span class="math inline">\(i\)</span>. By convexity of <span class="math inline">\(\Delta^n\)</span>, the offline optimum of our problem is interpreted as the energy of the lowest energy (i.e. <em>ground state</em>) expert at time <span class="math inline">\(t+1\)</span>,</p>
<p><span class="math display">\[ \min_{i\in\{1,...,n\}} E_t(i) \]</span></p>
<p>For any arbitrary “inverse temperature” parameter <span class="math inline">\(\beta\)</span>, we trivially have <span class="math inline">\(e^{-\beta\min_i E_t(i)}\le\sum_{i=1}^n e^{-\beta E_t(i)}\)</span> and so</p>
<p><span class="math display">\[ \min_{i\in\{1,...,n\}} E_t(i) \ge -\frac{1}{\beta}\log{\sum_{i=1}^n e^{-\beta E_t(i)}} \]</span></p>
<p>where <span class="math inline">\(\Phi_t = -\frac{1}{\beta}\log{\sum_{i=1}^n e^{-\beta E_t(i)}}\)</span> is the <strong>free energy</strong> at temperature <span class="math inline">\(1/\beta\)</span> at time <span class="math inline">\(t\)</span>. We will use this to establish a regret bound.</p>
<p>Given the energies of each expert, how do we decide on a distribution to sample them from? Statistical physics say to form a <a href="https://en.wikipedia.org/wiki/Boltzmann_distribution">Boltzmann-Gibbs distribution</a></p>
<p><span class="math display">\[ x_{t,i}=\frac{1}{Z_t}e^{-\beta E_t(i)} \]</span></p>
<p>where <span class="math inline">\(Z_t=\sum_{i=1}^n e^{-\beta E_t(i)}\)</span> is the <strong>partition function</strong> at time <span class="math inline">\(t\)</span>. This makes sense– we want to heed experts which have given us the least loss more often.</p>
<p>This choice of <span class="math inline">\(x_t\in\Delta^n\)</span> is the <strong>multiplicative weights algorithm</strong>:</p>
<pre class="code"><code>    maintain weights w_t = [w_t(1), w_t(2), ..., w_t(n)]
    update as
        w_t[i] &lt;- w_{t-1}[i] * exp(-beta * loss_{t-1}[i])
    generate strategy x_t as
        x_t[i] &lt;- w_t[i] / sum(w_t)</code></pre>
<p>which in Python can be given as</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> MultiplicativeWeights(Learner):</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_experts: <span class="bu">int</span>):</a>
<a class="sourceLine" id="cb5-3" title="3">        <span class="va">self</span>.num_experts <span class="op">=</span> num_experts</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="co"># initialize weights of experts to 1.0</span></a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="va">self</span>.weights <span class="op">=</span> np.repeat(<span class="fl">1.0</span>, num_experts)</a>
<a class="sourceLine" id="cb5-6" title="6">    </a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">def</span> generate(<span class="va">self</span>) <span class="op">-&gt;</span> np.ndarray:</a>
<a class="sourceLine" id="cb5-8" title="8">        <span class="cf">return</span> <span class="va">self</span>.weights <span class="op">/</span> np.<span class="bu">sum</span>(<span class="va">self</span>.weights)</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">def</span> suffer(<span class="va">self</span>, loss: np.ndarray):</a>
<a class="sourceLine" id="cb5-11" title="11">        gibbs_weights <span class="op">=</span> np.exp(<span class="op">-</span><span class="va">self</span>.beta <span class="op">*</span> loss)</a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="va">self</span>.weights <span class="op">*=</span> gibbs_weights</a></code></pre></div>
<p>Let us now determine the regret bound for this learning algorithm. Note that</p>
<p><span class="math display">\[
\begin{align*}
    \Phi_{t+1} - \Phi_t &amp;= -\frac{1}{\beta}\log{\sum_{i=1}^n e^{-\beta E_{t+1}(i)}}
        + \frac{1}{\beta}\log{\sum_{i=1}^n e^{-\beta E_t(i)}} \\
        &amp;= -\frac{1}{\beta}\log{\frac{Z_{t+1}}{Z_t}}
\end{align*}
\]</span></p>
<p>As <span class="math inline">\(E_{t+1}(i)=E_t(i)+\ell_i^t\)</span> and <span class="math inline">\(Z_{t+1}=\sum_{i=1}^n e^{-\beta E_t(i)}e^{-\beta\ell_i^t}\)</span>, we have</p>
<p><span class="math display">\[ 
\begin{align*}
    \frac{Z_{t+1}}{Z_t} &amp;= \sum_{i=1}^n\left(\frac{e^{-\beta E_t(i)}}{Z_t}\right)e^{-\beta\ell_i^t} \\
        &amp;= \sum_{i=1}^n x_{t,i} e^{-\beta\ell_i^t}
\end{align*}
\]</span></p>
<p>Assume, without loss of generality (we can rescale if necessary), that <span class="math inline">\(\|\ell^t\|_\infty\le 1\)</span> and <span class="math inline">\(|\beta|&lt;\frac{1}{2}\)</span>. Taylor expanding the exponential terms as</p>
<p><span class="math display">\[ e^{-\beta\ell_i^t} \le 1 - \beta\ell^t_i + \beta^2\ell_i^{t,2} \]</span></p>
<p>where <span class="math inline">\(\ell^{t,2}\)</span> is the pointwise square of the vector <span class="math inline">\(\ell^t\)</span>. We can replace in the equality above this expression to get the inequality</p>
<p><span class="math display">\[ 
\begin{align*}
    \frac{Z_{t+1}}{Z_t} &amp;\le \sum_{i=1}^n x_{t,i}\cdot(1 - \beta\ell^t_i + \beta^2\ell_i^{t,2}) \\
        &amp;= 1 - \beta\langle x_t,\ell^t\rangle + \beta^2\langle x_t, \ell^{t,2}\rangle
\end{align*}
\]</span></p>
<p>Since for <span class="math inline">\(|z|&lt;\frac{1}{2}\)</span>, <span class="math inline">\(1-z\le e^{-z}\)</span>, we get in this case that</p>
<p><span class="math display">\[ \frac{Z_{t+1}}{Z_t} \le \exp(- \beta\langle x_t,\ell^t\rangle + \beta^2\langle x_t, \ell^{t,2}\rangle) \]</span></p>
<p>so</p>
<p><span class="math display">\[
\begin{align*}
    \Phi_{t+1}-\Phi_t &amp;= -\frac{1}{\beta}\log\frac{Z_{t+1}}{Z_t} \\
        &amp;\ge -\frac{1}{\beta}\cdot\left(-\beta\langle x_t,\ell^t\rangle + \beta^2\langle x_t, \ell^{t,2}\rangle\right) \\
        &amp;= \langle x_t,\ell^t\rangle - \beta\langle x_t, \ell^{t,2}\rangle
\end{align*}
\]</span></p>
<p>Rearranging, we have</p>
<p><span class="math display">\[ \langle x_t,\ell^t \rangle \le \Phi_{t+1}-\Phi_t+\beta\langle x_t, \ell^{t,2}\rangle \]</span></p>
<p>Summing over <span class="math inline">\(t\)</span> and realizing we have a telescoping sum, we get</p>
<p><span class="math display">\[ \sum_{t=1}^T\langle x_t,\ell^t\rangle \le \Phi_{t+1}-\Phi_1 + \beta\sum_{t=1}^T\langle x_t,\ell^{t,2}\rangle \]</span></p>
<p>As <span class="math inline">\(\Phi_1=-\frac{1}{\beta}\log{n}\)</span> and <span class="math inline">\(\Phi_{T+1}\le\min_{j\in\{1,...,n\}}\sum_{t=1}^T \ell_j^t\)</span>, we combine the above to get</p>
<p><span class="math display">\[
\begin{align*}
    R^T &amp;= \sum_{t=1}^T\langle x_t,\ell^t\rangle - \min_{j\in\{1,...,n\}}\sum_{t=1}^T\ell_j^t \\
        &amp;\le \frac{\log{n}}{\beta} + \beta\sum_{t=1}^T\langle x_t,\ell^{t,2}\rangle \\
        &amp;\le \frac{\log{n}}{\beta} + \beta T
\end{align*}
\]</span></p>
<p>Taking <span class="math inline">\(T \ge 4\log{n}\)</span> and <span class="math inline">\(\beta=\sqrt{\frac{\log{n}}{T}}\)</span>, we get a regret bound</p>
<p><span class="math display">\[ R^T \le 2\sqrt{T\log{n}}. \]</span></p>
<h3 id="follow-the-regularized-leader">follow the regularized leader</h3>
<p>Multiplicative weights is a nice algorithm, but it isn’t clear how to extend it to other convex sets <span class="math inline">\(\mathcal{K}\)</span> that isn’t the probability simplex.</p>
<p>So instead, we start from scratch and think more generally– we assume nothing about <span class="math inline">\(\mathcal{K}\)</span> or <span class="math inline">\(\mathcal{F}\)</span> at the moment. What would guide us in choosing the next <span class="math inline">\(x_t\in\mathcal{K}\)</span> in our online convex optimization setting?</p>
<p>At time <span class="math inline">\(t\)</span>, all we have are our loss functions <span class="math inline">\(f_1, f_2,..., f_{t-1}\)</span>. If we have solutions that worked well in past time steps, why not just capitalize on those in a greedy fashion? The <strong>follow the leader</strong> algorithm does this: we take</p>
<p><span class="math display">\[ x_t = \argmin_{x\in\mathcal{K}}\sum_{k=1}^{t-1} f_k(x) \]</span></p>
<p>When does this do badly? Inutitively, FoL can <em>overfit</em> to past history– if we get sequences of conflicting loss functions, the algorithm can continually change its mind on the “best point” <span class="math inline">\(x_t\)</span>.</p>
<p>Formally, the regret bound shows this is the main failure of this algorithm:</p>
<p><span class="math display">\[ R^T \le \sum_{t=1}^T f_t(x_t) - f_t(x_{t+1}) \]</span></p>
<p>To see this, note by definition that</p>
<p><span class="math display">\[ R^T = \sum_{t=1}^T f_t(x_t) - \min_{x\in\mathcal{K}}\sum_{t=1}^T f_t(x) \]</span></p>
<p>So the regret bound above is equivalent to showing</p>
<p><span class="math display">\[  \min_{x\in\mathcal{K}}\sum_{t=1}^T f_t(x) \ge \sum_{t=1}^T f_t(x_{t+1}) \]</span></p>
<p>We show this by induction: in the base case (<span class="math inline">\(T=1\)</span>), we have <span class="math inline">\(\min_{x\in\mathcal{K}}f_1(x) = f_1(x_2)\)</span>, by definition of the FoL algorithm. Now assume this is true for <span class="math inline">\(T\)</span>. We decompose</p>
<p><span class="math display">\[ \sum_{t=1}^{T+1} f_t(x_{t+1}) = \left(\sum_{t=1}^T f_t(x_{t+1})\right) + f_{T+1}(x_{T+2}) \]</span></p>
<p>Note as <span class="math inline">\(\min_{x\in\mathcal{K}}\sum_{t=1}^T f_t(x)\le\sum_{t=1}^T f_t(x_{T+2})\)</span>, we have</p>
<p><span class="math display">\[
\begin{align*}
    \sum_{t=1}^{T+1} f_t(x_{t+1}) &amp;= \left(\sum_{t=1}^T f_t(x_{t+1})\right) + f_{T+1}(x_{T+2}) \\
        &amp;\le \left(\min_{x\in\mathcal{K}}\sum_{t=1}^T f_t(x)\right) + f_{T+1}(x_{T+2}) \\
        &amp;\le \sum_{t=1}^T f_t(x_{T+2}) + f_{T+1}(x_{T+2}) \\
        &amp;= \sum_{t=1}^{T+1} f_t(x_{T+2}) \\
        &amp;= \min_{x\in\mathcal{K}}\sum_{t=1}^{T+1} f_t(x)
\end{align*}
\]</span></p>
<p><span class="math inline">\(\square\)</span>.</p>
<p>This suggests that we should take smaller steps to balance out the old information we have from past cost functions with new ones from the environment.</p>
<p>We do this by introducing a <strong>regularizer</strong> <span class="math inline">\(R\)</span> and take at each time <span class="math inline">\(t\)</span> a <em>regularized step</em></p>
<p><span class="math display">\[ x_t = \argmin_{x\in\mathcal{K}}\left\{R(x) + \sum_{k=1}^{t-1} f_k(x)\right\} \]</span></p>
<p>This algorithm is <strong>follow the regularized leader</strong>, or FoReL.</p>
<p>What is the regret bound generically for FoReL? Let <span class="math inline">\(x_1,..., x_t\)</span> be the sequence generated by FoReL on <span class="math inline">\(\mathcal{K}\)</span> with cost functions <span class="math inline">\(f_1,..., f_t\)</span>.</p>
<p><strong>Theorem:</strong> Let <span class="math inline">\(R^T(x)=\sum_{t=1}^T\left(f_t(x_t) - f_t(x)\right)\)</span>. Then</p>
<p><span class="math display">\[ R^T(x) \le R(x) - R(x_1) + \sum_{t=1}^T\left(f_t(x_t) - f_t(x_{t+1})\right). \]</span></p>
<p><em>Proof:</em> Consider FoReL to be a FoL process with losses <span class="math inline">\(R, f_1, f_2,...\)</span>. Starting with <span class="math inline">\(x_1\)</span>, FoL would generate <span class="math inline">\(x_1, x_1, x_2,...,x_T\)</span>. The previous regret bound for FoL gives the regret bound above. <span class="math inline">\(\square\)</span></p>
<p>FoReL encompasses a very general online optimization procedure, and leads to many other popular algorithms in use. For example, we will now use FoReL to rediscover the multiplicative weights algorithm. If we were to run FoL on the expert advice problem, we would find that it tends to concentrate probability on a single expert. To “spread out” the distribution, we would want to increase the entropy (i.e. information spread) of the resulting distribution. Since we’re minimizing cost, we will use <strong>negentropy</strong> (i.e. negative of entropy) as the regularizer</p>
<p><span class="math display">\[ R(x) = c \cdot \sum_{i=1}^n x_i\log{x_i} \]</span></p>
<p>Consider FoReL on <span class="math inline">\(\Delta^n\)</span> with negentropic regularization:</p>
<p><span class="math display">\[ x_t = \argmin_{x\in\mathcal{K}}\left\{\sum_{k=1}^{t-1} \langle\ell^k, x\rangle + c\cdot\sum_{i=1}^n x_i\log{x_i}\right\} \]</span></p>
<p>Solving by <a href="https://en.wikipedia.org/wiki/Lagrange_multiplier">Lagrange multipliers</a>, we want to find the Jacobian of</p>
<p><span class="math display">\[ f(x,\lambda)=\sum_{k=1}^{t-1}\langle\ell^k, x\rangle + c\cdot\sum_{i=1}^n x_i\log{x_i} + \lambda\left(1-\sum_{i=1}^n x_i\right) \]</span></p>
<p>Taking derivatives,</p>
<p><span class="math display">\[ \partial_{x_i}f(x,\lambda) = \sum_{k=1}^{t-1}\ell_i^k+c(1+\log{x_i})+\lambda \]</span></p>
<p>and setting to <span class="math inline">\(0\)</span> at the minima, gives</p>
<p><span class="math display">\[ x_i = \exp\left(-1-\frac{\lambda}{c}-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right) \]</span></p>
<p>Since <span class="math inline">\(\sum_{i=1}^n x_i = 1\)</span> as <span class="math inline">\(x\in\Delta^n\)</span>, we can arrange</p>
<p><span class="math display">\[
\begin{align*}
    1 = \sum_{i=1}^n x_i &amp;= \sum_{i=1}^n e^{-1-\frac{\lambda}{c}}\exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right) \\
        &amp;= e^{-1-\frac{\lambda}{c}}\sum_{i=1}^n \exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right)
\end{align*}
\]</span></p>
<p>which shows that</p>
<p><span class="math display">\[ e^{1+\frac{\lambda}{c}} = \sum_{i=1}^n \exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right) \]</span></p>
<p>and hence, solving for <span class="math inline">\(\lambda\)</span>:</p>
<p><span class="math display">\[ \lambda = c\left(-1 + \log\sum_{i=1}^n\exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right)\right) \]</span></p>
<p>Plugging this multiplier in gives</p>
<p><span class="math display">\[ x_i = \frac{\exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_i^k\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{c}\sum_{k=1}^{t-1}\ell_j^k\right)} \]</span></p>
<p>If we choose <span class="math inline">\(c=\frac{1}{\beta}\)</span>, we get the multiplicative weights algorithm!</p>
<h3 id="computing-forel">computing FoReL</h3>
<p>In this section, we will take a look at computing the FoReL dynamics. Considering it as a discrete dynamical system, we want to iteratively compute</p>
<p><span class="math display">\[ x_{t+1} = \argmin_{x\in\mathcal{K}}\left\{R(x) + \sum_{k=1}^t f_k(x)\right\} \]</span></p>
<p>for each time step <span class="math inline">\(t\)</span>. However, computing this requires taking an <code>argmax</code> over a entire convex space, which is itself a (constrained) optimization problem. Is there a way to reduce this to a sequence of easier optimization settings?</p>
<p>Consider the case where the regularization function <span class="math inline">\(R(x)\)</span> is a quadratic norm <span class="math inline">\(R(x)=\frac{1}{2}\|x\|^2\)</span>, that is,</p>
<p><span class="math display">\[ x_{t+1} = \argmin_{x\in\mathcal{K}}\left\{\eta\sum_{s=1}^t f_t(x) + \frac{1}{2}\|x\|^2\right\} \]</span></p>
<p>We start by looking at the case where the convex loss functions <span class="math inline">\(f_s\)</span> are <strong>linear</strong>, that is <span class="math inline">\(f_s(x) = \nabla{f_s}\cdot x\)</span>. In this case, the problem above simplifies– by definition of <span class="math inline">\(x_{t+1}, x_t\)</span>,</p>
<p><span class="math display">\[ \nabla \left\{\eta\sum_{s=1}^t f_t(x) + \frac{1}{2}\|x\|^2\right\}(x_{t+1}) = \eta\sum_{s=1}^t\nabla{f_s} + x_{t+1} = 0 \]</span></p>
<p>and</p>
<p><span class="math display">\[ \nabla \left\{\eta\sum_{s=1}^{t-1} f_t(x) + \frac{1}{2}\|x\|^2\right\}(x_t) = \eta\sum_{s=1}^{t-1}\nabla{f_s} + x_t = 0 \]</span></p>
<p>Hence, combining the two we see that</p>
<p><span class="math display">\[ x_{t+1} = x_t - \eta\nabla{f_t}(x_t) \]</span></p>
<p>which is <strong>online gradient descent</strong>. In particular, the FoReL dynamics here is solvable in a “closed form”, and only involves the most recent loss function at that time step. Indeed, this is the main computational gain: we turn a minimization problem involving all losses <span class="math inline">\(f_s\)</span> up to time <span class="math inline">\(t\)</span> into a problem involving just one of them, <span class="math inline">\(f_t\)</span>.</p>
<p>This argument can be extended, but in order to do so, we need to modify our notion of “distance to a solution”. Indeed, we will effectively try and turn our constrained optimization problem, into an unconstrained one but in a “different metric space” of sorts.</p>
<p>Consider the regularized minimization problem</p>
<p><span class="math display">\[ x_{t+1} = \argmin_{x\in\mathcal{K}}\left\{R(x) + \sum_{k=1}^t f_k(x)\right\} \]</span></p>
<p>and iterative define</p>
<p><span class="math display">\[ \Phi_0 = R \\ \Phi_t = \Phi_{t-1} + \eta f_t \]</span></p>
<p>Then we can write <span class="math inline">\(x_{t+1} = \argmin_{x\in\mathcal{K}}\Phi_t(x)\)</span>. For <span class="math inline">\(\Phi:\mathbf{R}^n\to\mathbf{R}\)</span>, define the <strong>Bregman divergence</strong> with respect to <span class="math inline">\(\Phi\)</span> as</p>
<p><span class="math display">\[ D_\Phi(a, b) = \Phi(a) - (\Phi(b)+\nabla{\Phi}(b)\cdot(a-b)) \]</span></p>
<p>which is the difference between <span class="math inline">\(\Phi(a)\)</span> and the first-order approximation of <span class="math inline">\(\Phi(a)\)</span> centered at <span class="math inline">\(b\)</span>.</p>
<p>Here are two basic examples: First, let <span class="math inline">\(\Phi(a)=\frac{1}{2}\|a\|^2\)</span>. Then the Bregman divergence corresponding to this function is given by</p>
<p><span class="math display">\[
\begin{align*}
    D_\Phi(a, b) &amp;= \frac{1}{2}\|a\|^2-\frac{1}{2}\|b\|^2-b\cdot(a-b) \\
        &amp;= \frac{1}{2}\|a\|^2 + \frac{1}{2}\|b\|^2 - a^\top b \\
        &amp;= \frac{1}{2}\|a-b\|^2
\end{align*}
\]</span></p>
<p>For a second example, let <span class="math inline">\(\Phi(a)=\sum_i a_i\log{a_i}\)</span>, the entropy function. Computing the Bregman divergence:</p>
<p><span class="math display">\[
\begin{align*}
    D_\Phi(a, b) &amp;= \sum_i a_i\log{a_i}-\sum_i b_i\log{b_i} - \sum_i (\log{b_i}+1)(a_i-b_i) \\
        &amp;= \sum_i a_i\log{\frac{a_i}{b_i}}
\end{align*}
\]</span></p>
<p>as <span class="math inline">\(\sum_i a_i = 1 = \sum_i b_i\)</span>. Here we see that the Bregman divergence in this case is the Kullback-Leibner divergence.</p>
<p>For now, consider the case of linear losses. In the unconstrained optimization situation (<span class="math inline">\(\mathcal{K}=\mathbf{R}^d\)</span>), we are trying to iteratively solve the dynamics</p>
<p><span class="math display">\[ \tilde{x}_{t+1} = \argmin_{x\in\mathbf{R}^d}\left\{\eta\sum_{s=1}^t g_s\cdot x + R(x)\right\} \]</span></p>
<p>where here the tilde denotes the unconstrained dynamics. As in the argument before, we can let</p>
<p><span class="math display">\[ \nabla R(\tilde{x}_{t+1})=\eta\sum_{s=1}^t g_s \\ \nabla R(\tilde{x}_t)=\eta\sum_{s=1}^{t-1} g_s \]</span></p>
<p>by definition of <span class="math inline">\(\tilde{x}_{t+1}, \tilde{x}_t\)</span>. Hence <span class="math inline">\(\nabla R(\tilde{x}_{t+1})=\nabla R(\tilde{x}_t)-\eta g_t\)</span>, and so</p>
<p><span class="math display">\[ \tilde{x}_{t+1} = \nabla R^{-1}(\nabla R(\tilde{x}_t)-\eta g_t) \]</span></p>
<p>which is a generalization of online gradient descent called <strong>mirror descent</strong>.</p>
<p>How do we deal with the constrained optimization case? It turns out that all we need to do is solve the unconstrained case and then “project” the answer down onto the constraints, i.e. the convex set <span class="math inline">\(\mathcal{K}\)</span> we’re optimizing over. Formalizing this, let</p>
<p><span class="math display">\[ \Pi^\Phi_\mathcal{K}(b) = \argmin_{a\in\mathcal{K}} D_\Phi(a, b) \]</span></p>
<p>be the <strong>Bregman projection</strong> of <span class="math inline">\(b\in\mathbf{R}^d\)</span> onto <span class="math inline">\(\mathcal{K}\subset\mathbf{R}^d\)</span> via the divergence <span class="math inline">\(D_\Phi\)</span>.</p>
<p><strong>Theorem:</strong> Let <span class="math inline">\(x_{t+1} = \argmin_{x\in\mathcal{K}}\Phi_t(x)\)</span> be the constrained optimization iterate, and <span class="math inline">\(\tilde{x}_{t+1} = \argmin_{x\in\mathbf{R}^d}\Phi_t(x)\)</span> the corresponding unconstrained iterate. Then they are related by the Bregman projection:</p>
<p><span class="math display">\[ x_{t+1} = \Pi_\mathcal{K}^{\Phi_t}(\tilde{x}_{t+1}) \]</span></p>
<p><em>Proof:</em> Let <span class="math inline">\(x'_{t+1}=\Pi_\mathcal{K}^{\Phi_t}(\tilde{x}_{t+1})\)</span>. By definition,</p>
<p><span class="math display">\[ \Phi_t(x_{t+1}) \le \Phi_t(x'_{t+1}) \]</span></p>
<p>Conversely, <span class="math inline">\(D_{\Phi_t}(x'_{t+1},\tilde{x}_{t+1})\le D_{\Phi_t}(x_{t+1},\tilde{x}_{t+1})\)</span> by definition of the Bregman projection. As <span class="math inline">\(\nabla\Phi_t(\tilde{x}_{t+1})=0\)</span>, we have</p>
<p><span class="math display">\[ D_{\Phi_t}(x,\tilde{x}_{t+1})=\Phi_t(x)-\Phi_t(\tilde{x}_{t+1}) \]</span></p>
<p>and so <span class="math inline">\(\Phi_t(x'_{t+1})\le\Phi_t(x_{t+1})\)</span>. This implies <span class="math inline">\(x_{t+1}=x'_{t+1}\)</span>. <span class="math inline">\(\square\)</span></p>
<p>Hence, with linear losses, the constrained optimization solution becomes</p>
<p><span class="math display">\[ x_{t+1} = \Pi^{\Phi_t}_\mathcal{K}\left(\nabla R^{-1}(\nabla R(\tilde{x}_t)-\eta g_t)\right) \]</span></p>
<p>In general, we won’t have linear losses. What do we take as our unconstrained minimizers in this case? Let</p>
<p><span class="math display">\[ \tilde{x}_{t+1} = \argmin_{x\in\mathbf{R}^d}\left\{\eta f_t(x) + D_{\Phi_{t-1}}(x, \tilde{x}_t)\right\} \]</span></p>
<p>We can prove this is a minimizer of <span class="math inline">\(\Phi_t\)</span>: by definition of <span class="math inline">\(\Phi_t\)</span>,</p>
<p><span class="math display">\[ \eta f_t(x) + D_{\Phi_{t-1}}(x, \tilde{x}_t) = \Phi_t(x) - \Phi_{t-1}(x) + D_{\Phi_{t-1}}(x, \tilde{x}_t) \]</span></p>
<p>Taking gradients with respect to <span class="math inline">\(x\)</span>,</p>
<p><span class="math display">\[ \nabla \Phi_t(x) - \nabla \Phi_{t-1}(x) + \nabla_x D_{\Phi_{t-1}}(x,\tilde{x}_t) \]</span></p>
<p>and noting that <span class="math inline">\(\nabla_x D_{\Phi_{t-1}}(x,\tilde{x}_t)=\nabla\Phi_{t-1}(x)-\nabla\Phi_{t-1}(\tilde{x}_t)\)</span>, setting to zero gives</p>
<p><span class="math display">\[ \nabla\Phi_t(\tilde{x}_{t+1})=\nabla\Phi_{t-1}(\tilde{x}_t) \]</span></p>
<p>which inductively can be shown to be zero. So <span class="math inline">\(\tilde{x}_{t+1}\)</span> minimizes <span class="math inline">\(\Phi_t\)</span>. As before, the constrained dynamics are given by Bregman projection.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
