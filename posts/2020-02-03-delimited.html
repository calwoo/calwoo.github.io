<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" type="image/x-icon" href="../favicon.ico" />
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Delimited continuations - Calvin Woo's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Calvin's Notebook</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Delimited continuations</h1>
            <article>
    <section class="header">
        Posted on February  3, 2020
        
            by Calvin
        
    </section>
    <section>
        <p><strong>Note: This blog post is still a rough draft. Read on with caution.</strong></p>
<p>Some of the most amazing quality-of-life features of many programming languages are centered around control flow. For example, lazy-evaluated iterators in the form of generators in Python, async/await for asynchronous control, etc. are all ways to improve the control flow in a language. However, as more disciplines become more computational, it is becoming apparent that new types of control flow operators are necessary. For example, modern machine learning relies heavily on reverse-mode autodifferentiation, which in many languages is implemented as a secondary DSL embedded in the host language.</p>
<p>Wouldn’t it be great if our languages had an abstraction that allowed us to build any control flow operator we wanted? These atomic objects are known a <strong>delimited continuations</strong>. Recall that a <em>continuation</em> is merely an abstraction of “the rest of a computation”. For example, consider the following computation</p>
<pre><code>if x == 0 then 1 + 3 else 4</code></pre>
<p>After the evaluation of <code>x == 0</code>, its continuation is the remaining <em>holed-computation</em></p>
<pre><code>if [] then 1 + 3 else 4</code></pre>
<p>However, these aren’t really true continuations! Philosophically, the continuation extends beyond the code, to the effects generated by the hardware, etc. Hence, we really want to consider continuations restricted to a certain point. These are delimited continuations, and these are the objects that can be reified into functions in the host language. Delimited continuations allow us to manipulate the control flow of our programs. And although monads allow us to control the sequential flow of computational effects in our programs, delimited continuations give us the flexibility to do more with that control.</p>
<h3 id="shiftreset">shift/reset</h3>
<p>Delimited continuations are realized in a language via <em>control operators</em>, which allow us to capture both the scope of the continuation and to express the flow of the program. The most written about operators are <code>shift</code> and <code>reset</code>, though there are <a href="http://homes.sice.indiana.edu/ccshan/recur/recur.pdf">others</a> in the PLT literature.</p>
<p>First we recall continuations in Haskell. A continuation is a suspended computation, that is, to resume it we need to give it a callback. Hence the type is given by</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>To understand the monadic instance, it might be easier to see what happens in CPS (Python):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> f(x, k):</a>
<a class="sourceLine" id="cb4-2" title="2">    y <span class="op">=</span> <span class="op">&lt;</span>computation <span class="kw">in</span> f<span class="op">&gt;</span>(x)</a>
<a class="sourceLine" id="cb4-3" title="3">    k(y)</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">def</span> g(y, k):</a>
<a class="sourceLine" id="cb4-6" title="6">    z <span class="op">=</span> <span class="op">&lt;</span>computation <span class="kw">in</span> g<span class="op">&gt;</span>(y)</a>
<a class="sourceLine" id="cb4-7" title="7">    k(z)</a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">def</span> comp_g_f(x, k):</a>
<a class="sourceLine" id="cb4-10" title="10">    f(x, <span class="kw">lambda</span> y: g(y, k))</a></code></pre></div>
<p>In Haskell, this same inversion of control is explicit in the monad instance:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a </a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \rest <span class="ot">-&gt;</span> rest a</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b </a>
<a class="sourceLine" id="cb5-8" title="8">    f <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> runCont f (\a <span class="ot">-&gt;</span> runCont (g a) k)</a></code></pre></div>
<p>Next we turn our heads towards the control operators <code>shift/reset</code>. The semantics are fairly complicated, so it suffices to look at an example. Lets look at the expression</p>
<pre><code>1 + reset (2 * (shift \k -&gt; k (k 5)))</code></pre>
<p>The way to interpret this is to look at the bound variable <code>k</code> in <code>shift</code>. It is bound to the continuation outside the <code>shift</code>, delimited by the <code>reset</code>, which in this case is given by <code>2 * []</code>. Hence <code>k 5</code> is <code>5</code> applied to this continuation, so <code>10</code>. Applying <code>k</code> again gives <code>20</code>, so we replace the above with <code>1 + 20 == 21</code>.</p>
<p>Written out, we can express these two control operators in terms of the continuation monad:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="co">-- helper function for running computations</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">runC ::</span> <span class="dt">Cont</span> r r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb7-3" title="3">runC ct <span class="fu">=</span> runCont ct <span class="fu">id</span></a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="ot">reset ::</span> <span class="dt">Cont</span> a a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</a>
<a class="sourceLine" id="cb7-6" title="6">reset f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \rest <span class="ot">-&gt;</span> rest <span class="fu">$</span> runC f</a></code></pre></div>
<p><code>reset</code> wraps a computation to set the boundaries of the delimited continuation. Once the computation inside finishes, it returns the rest of the computation outside of the reset statement. The <code>shift</code> operator is a bit trickier:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">shift ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</a>
<a class="sourceLine" id="cb8-2" title="2">shift f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> runC (f k)</a></code></pre></div>
<p>The input to <code>shift</code> is a function that takes a callback function to form a computation. All <code>shift</code> does is run this continuation! By itself, this does nothing– there isn’t any control flow present here. However when combined with <code>reset</code>, the callback <code>k</code> is bound to the “continuation delimited by <code>reset</code>”.</p>
<p>As an example, we use the computation above, translated to Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">example ::</span> <span class="dt">Cont</span> <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" title="2">example <span class="fu">=</span> liftM2 (<span class="fu">+</span>) (<span class="fu">return</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-3" title="3">                     reset (liftM2 (<span class="fu">*</span>) (<span class="fu">return</span> <span class="dv">2</span>) </a>
<a class="sourceLine" id="cb9-4" title="4">                           (shift (\k <span class="ot">-&gt;</span> k <span class="fu">&lt;$&gt;</span> k <span class="fu">&lt;$&gt;</span> (<span class="fu">return</span> <span class="dv">5</span>))))</a></code></pre></div>
<p>Notice the Scheme-esque parentheses and operators! Anyway, it’s fairly straightforward to lift these things. Evaluating with <code>runC</code> we get our desired answer.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">&gt;</span> runC example</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dv">21</span></a></code></pre></div>
<h3 id="exceptions-as-control">exceptions as control</h3>
<p>People who use Python (I refuse to use the neologism for them) are familiar continuations even though they aren’t first-class objects in the language– they use exceptions! Exceptions capture the control stack at a future time and allows one to swap out for that stack completely when an error is raised.</p>
<p>This effect can be replicated via delimited continuations. Throwing an exception can be thought of as interrupting a computation in a <code>try</code>-block, forcing the short-circuiting of the block. As above, this is a <code>shift</code>-block where the callback is ignored, and instead control is handed directly to a handler object:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">throw ::</span> e <span class="ot">-&gt;</span> <span class="dt">Cont</span> e a</a>
<a class="sourceLine" id="cb11-2" title="2">throw e <span class="fu">=</span> shift (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> (\h <span class="ot">-&gt;</span> h e))</a></code></pre></div>
<p>Of course, a <code>throw</code> statement is useless without a handler to deal with it (this is the framework of algebraic effects that I’ll talk about in a later post). This is given by a try-except block: The computation occurs in the try statement until a <code>throw</code> statement is encountered. In this case, the computation’s continuation in the try block is ignored, and control is completely given to the handler. This is a delimited continuation, where the try is contained in a <code>reset</code>!</p>
<p>However, this is a bit tricky to write. To simplify matters, lets look at how we can just exit from a computation early (without handling the output). Just like the <code>throw</code> statement, an early exit in a delimited continuation is a <code>shift</code>-block:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">exit ::</span> e <span class="ot">-&gt;</span> <span class="dt">Cont</span> e a</a>
<a class="sourceLine" id="cb12-2" title="2">exit e <span class="fu">=</span> shift (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> e)</a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4">test <span class="fu">=</span> reset (liftM2 (<span class="fu">+</span>) (<span class="fu">return</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb12-5" title="5">             (shift (\k <span class="ot">-&gt;</span> k <span class="fu">&lt;$&gt;</span> (exit <span class="dv">0</span>))))</a></code></pre></div>
<p>Running the above results in 0, which is the exit value. However, the exit value is undistinguished from a normal value, which is bad since thrown exit values should be passed to the exception handler, while normal values ignore it. We could distinguish it by creating a custom type, or we can “functionalize” the continuation. This trick gives the try-except block:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">tryExcept ::</span> (e <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> ((e <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb13-2" title="2">tryExcept h s <span class="fu">=</span> runCont (reset </a>
<a class="sourceLine" id="cb13-3" title="3">                            (<span class="kw">do</span>  </a>
<a class="sourceLine" id="cb13-4" title="4">                                x <span class="ot">&lt;-</span> s</a>
<a class="sourceLine" id="cb13-5" title="5">                                <span class="fu">return</span> (\_ <span class="ot">-&gt;</span> x))) hf</a>
<a class="sourceLine" id="cb13-6" title="6">                            <span class="kw">where</span> hf <span class="fu">=</span> <span class="fu">flip</span> (<span class="fu">$</span>) h</a></code></pre></div>
<p>As an example of how it works, look at</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">example1 <span class="fu">=</span> tryExcept (\e <span class="ot">-&gt;</span> e <span class="fu">+</span> <span class="dv">42</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb14-2" title="2">                     (liftM2 (<span class="fu">+</span>) (<span class="fu">return</span> <span class="dv">17</span>) (<span class="fu">return</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">example2 <span class="fu">=</span> tryExcept (\e <span class="ot">-&gt;</span> e <span class="fu">+</span> <span class="dv">42</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb14-5" title="5">                     (liftM2 (<span class="fu">+</span>) (<span class="fu">return</span> <span class="dv">17</span>) (throw <span class="dv">4</span>))</a></code></pre></div>
<p>Running <code>example1</code> gives 21, as nothing is thrown. However, in <code>example2</code> a <code>throw</code> statement is called with the exception value 4, which is handled in the handler <code>\e -&gt; e + 42</code> giving us 46 as the final value.</p>
<h3 id="the-yield-statement">the yield statement</h3>
<p>Our delimited continuations are awesome, and we wish languages had a fun way to expose these objects without turning to continuation-passing style (CPS). (Yes, the <code>Cont</code> monad is CPS– code written wrapped in the <code>Cont</code>-context is implicitly in CPS). It turns out that languages that expose a <code>yield</code> primitive actually have a way to access delimited continuations! This is the central result of the paper by James-Sabry <a href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf">“Yield: Mainstream delimited continuations”</a>, written by two professors at IU. For some reason I never really spent any time near Lindley Hall (the CS department) even though Rawles was literally across the street…</p>
<p>Since <code>yield</code> statements are used in Python generators, let’s explore how to build a generator with continuations. Recall that a generator is effectively a lazy iterator. What this entails is that once a generator is called to output a value, it <em>suspends</em> until the next time it is called. This should immediately scream reified continuation! A generator will output not only a value, but also keeps track of the reified continuation corresponding to the remainder of the iterator. When the generator resumes, it merely starts over by running this continuation object.</p>
<p>We can capture these continuations using the <code>reset/shift</code> control operators. Consider an example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">gen <span class="fu">=</span> reset (<span class="kw">do</span></a>
<a class="sourceLine" id="cb15-2" title="2">            (shift (\k <span class="ot">-&gt;</span> liftM2 (<span class="fu">:</span>) (<span class="fu">return</span> <span class="dv">1</span>) (k <span class="fu">&lt;$&gt;</span> (<span class="fu">return</span> []))))</a>
<a class="sourceLine" id="cb15-3" title="3">            (shift (\k <span class="ot">-&gt;</span> liftM2 (<span class="fu">:</span>) (<span class="fu">return</span> <span class="dv">2</span>) (k <span class="fu">&lt;$&gt;</span> (<span class="fu">return</span> []))))</a>
<a class="sourceLine" id="cb15-4" title="4">            (shift (\k <span class="ot">-&gt;</span> liftM2 (<span class="fu">:</span>) (<span class="fu">return</span> <span class="dv">3</span>) (k <span class="fu">&lt;$&gt;</span> (<span class="fu">return</span> [])))))</a></code></pre></div>
<p>We see that in this, whenever the expression <code>k &lt;$&gt; (return [])</code> is reached, a continuation is reified, and that continuation object represents the rest of the iteration! When we run this generator we get back <code>[1,2,3]</code>. We abstract the repeated statement– this is a <code>yield</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">yield x <span class="fu">=</span> shift (\k <span class="ot">-&gt;</span> liftM2 (<span class="fu">:</span>) (<span class="fu">return</span> x) (k <span class="fu">&lt;$&gt;</span> (<span class="fu">return</span> [])))</a></code></pre></div>
<p>This <code>yield</code> statement has the right credentials: calling it suspends the computation by reifying the remainder of the computation, which exists outside of the <code>shift</code> statement. With this operator, we get the generator as:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">gen <span class="fu">=</span> reset (<span class="kw">do</span></a>
<a class="sourceLine" id="cb17-2" title="2">                yield <span class="dv">1</span></a>
<a class="sourceLine" id="cb17-3" title="3">                yield <span class="dv">2</span></a>
<a class="sourceLine" id="cb17-4" title="4">                yield <span class="dv">3</span>)</a></code></pre></div>
<p>The main insight of the above paper is a generator (with <code>yield</code> statement) entirely encapsulates a delimited continuation, where each <code>yield</code> statement is equivalent to a <code>shift</code> statement. In this way, the <code>reset</code> block tells us how to run the generator. This can be extracted in familiar language as <code>run</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">run e <span class="fu">=</span> reset (<span class="kw">do</span> x <span class="ot">&lt;-</span> e; <span class="fu">return</span> x)</a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3">gen <span class="fu">=</span> run (yield <span class="dv">1</span> <span class="fu">&gt;&gt;</span> yield <span class="dv">2</span> <span class="fu">&gt;&gt;</span> yield <span class="dv">3</span>)</a></code></pre></div>
<p>We see that running <code>gen</code> gives back our <code>[1,2,3]</code> as desired.</p>
<h3 id="python">python?</h3>
<p>Since Python generators are so prevalent, could we use them like delimited continuations? As an experiment, I wanted to try replicating the above exception handling. However I ran into an issue– generators are not really designed to be flattened. I needed multiple layers of generators, and the <code>yield</code> statements in Python seems to only capture the continuation in its base generator.</p>
<p>This presents a small issue. It seems like Python generators and its built-in try/except exception handling are orthogonal abstractions! This is exploitable, and is the focus of one of my favorite papers in computer science: thermometer continuations. This is the content of my next post.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
